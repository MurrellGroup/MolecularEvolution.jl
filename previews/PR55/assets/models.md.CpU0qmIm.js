import{_ as l,C as p,c as r,o as d,aA as t,j as s,G as e,a as n,w as o}from"./chunks/framework.Bizz6vH1.js";const w=JSON.parse('{"title":"Models","description":"","frontmatter":{},"headers":[],"relativePath":"models.md","filePath":"models.md","lastUpdated":null}'),h={name:"models.md"},c={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""};function y(E,i,m,b,f,C){const a=p("Badge");return d(),r("div",null,[i[16]||(i[16]=t('<h1 id="models" tabindex="-1">Models <a class="header-anchor" href="#models" aria-label="Permalink to &quot;Models&quot;">​</a></h1><p>Coming soon.</p><h2 id="Discrete-state-models" tabindex="-1">Discrete state models <a class="header-anchor" href="#Discrete-state-models" aria-label="Permalink to &quot;Discrete state models {#Discrete-state-models}&quot;">​</a></h2><h3 id="Codon-models" tabindex="-1">Codon models <a class="header-anchor" href="#Codon-models" aria-label="Permalink to &quot;Codon models {#Codon-models}&quot;">​</a></h3><h2 id="Continuous-models" tabindex="-1">Continuous models <a class="header-anchor" href="#Continuous-models" aria-label="Permalink to &quot;Continuous models {#Continuous-models}&quot;">​</a></h2><h2 id="Compound-models" tabindex="-1">Compound models <a class="header-anchor" href="#Compound-models" aria-label="Permalink to &quot;Compound models {#Compound-models}&quot;">​</a></h2><h2 id="Lazy-models" tabindex="-1">Lazy models <a class="header-anchor" href="#Lazy-models" aria-label="Permalink to &quot;Lazy models {#Lazy-models}&quot;">​</a></h2><h3 id="lazypartition" tabindex="-1">LazyPartition <a class="header-anchor" href="#lazypartition" aria-label="Permalink to &quot;LazyPartition&quot;">​</a></h3>',8)),s("details",c,[s("summary",null,[i[0]||(i[0]=s("a",{id:"MolecularEvolution.LazyPartition-models",href:"#MolecularEvolution.LazyPartition-models"},[s("span",{class:"jlbinding"},"MolecularEvolution.LazyPartition")],-1)),i[1]||(i[1]=n()),e(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[3]||(i[3]=t('<p><strong>Constructor</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LazyPartition{PType}()</span></span></code></pre></div><p>Initialize an empty <code>LazyPartition</code> that is meant for wrapping a partition of type <code>PType</code>.</p><p><strong>Description</strong></p><p>With this data structure, you can wrap a partition of choice. The idea is that in some message passing algorithms, there is only a wave of partitions which need to actualize. For instance, a wave following a root-leaf path, or a depth-first traversal. In which case, we can be more economical with our memory consumption. With a worst case memory complexity of O(log(n)), where n is the number of nodes, functionality is provided for:</p><ul><li><p><code>log_likelihood!</code></p></li><li><p><code>felsenstein!</code></p></li><li><p><code>sample_down!</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>For successive <code>felsenstein!</code> calls, we need to extract the information at the root somehow after each call. This can be done with e.g. <code>total_LL</code> or <code>site_LLs</code>.</p></div><p><strong>Further requirements</strong></p><p>Suppose you want to wrap a partition of <code>PType</code> with <code>LazyPartition</code>:</p><ul><li><p>If you&#39;re calling <code>log_likelihood!</code> and <code>felsenstein!</code>:</p><ul><li><code>obs2partition!(partition::PType, obs)</code> that transforms an observation to a partition.</li></ul></li><li><p>If you&#39;re calling <code>sample_down!</code>:</p><ul><li><code>partition2obs(partition::PType)</code> that returns the most likely state from a partition, inverts <code>obs2partition!</code>.</li></ul></li></ul>',10)),e(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>i[2]||(i[2]=[s("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3da9349ef066bc4c0cea77e06324d516fdc7421b/src/models/lazy_models/lazy_partition.jl#L2-L25",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i[17]||(i[17]=t(`<h4 id="examples" tabindex="-1">Examples <a class="header-anchor" href="#examples" aria-label="Permalink to &quot;Examples&quot;">​</a></h4><h5 id="Example-1:-Initializing-for-an-upward-pass" tabindex="-1">Example 1: Initializing for an upward pass <a class="header-anchor" href="#Example-1:-Initializing-for-an-upward-pass" aria-label="Permalink to &quot;Example 1: Initializing for an upward pass {#Example-1:-Initializing-for-an-upward-pass}&quot;">​</a></h5><p>Now, we show how to wrap the <code>CodonPartition</code>s from <a href="/MolecularEvolution.jl/previews/PR55/examples#Example-3:-FUBAR">Example 3: FUBAR</a> with <code>LazyPartition</code>:</p><p>You simply go from initializing messages like this:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">initial_partition </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CodonPartition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(seqs[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">initial_partition</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state .</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> eq_freqs</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">populate_tree!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree,initial_partition,seqnames,seqs)</span></span></code></pre></div><p>To this</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">initial_partition </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CodonPartition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(seqs[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">initial_partition</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state .</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> eq_freqs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lazy_initial_partition </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LazyPartition{CodonPartition}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">populate_tree!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree,lazy_initial_partition,seqnames,seqs)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lazyprep!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree, initial_partition)</span></span></code></pre></div><p>By this slight modification, we go from initializing and using 554 partitions to 6 during the subsequent <code>log_likelihood!</code> and <code>felsenstein!</code> calls. There is no significant decrease in performance recorded from this switch.</p><h5 id="Example-2:-Initializing-for-a-downward-pass" tabindex="-1">Example 2: Initializing for a downward pass <a class="header-anchor" href="#Example-2:-Initializing-for-a-downward-pass" aria-label="Permalink to &quot;Example 2: Initializing for a downward pass {#Example-2:-Initializing-for-a-downward-pass}&quot;">​</a></h5><p>Now, we show how to wrap the <code>GaussianPartition</code>s from <a href="/MolecularEvolution.jl/previews/PR55/intro#Quick-example:-Likelihood-calculations-under-phylogenetic-Brownian-motion:">Quick example: Likelihood calculations under phylogenetic Brownian motion:</a> with <code>LazyPartition</code>:</p><p>You simply go from initializing messages like this:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">internal_message_init!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GaussianPartition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>To this (technically we only add 1 LOC)</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">initial_partition </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GaussianPartition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lazy_initial_partition </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LazyPartition{GaussianPartition}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">internal_message_init!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree, lazy_initial_partition)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lazyprep!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree, initial_partition, direction</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LazyDown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(isleafnode))</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">Note</p><p>Now, we provided a direction for <code>lazyprep!</code>. The direction is an instance of <code>LazyDown</code>, which was initialized with the <code>isleafnode</code> function. The function <code>isleafnode</code> dictates if a node saves its sampled observation after a down pass. If you use <code>direction=LazyDown()</code>, every node saves its observation.</p></div><h4 id="Surrounding-LazyPartition" tabindex="-1">Surrounding LazyPartition <a class="header-anchor" href="#Surrounding-LazyPartition" aria-label="Permalink to &quot;Surrounding LazyPartition {#Surrounding-LazyPartition}&quot;">​</a></h4>`,16)),s("details",k,[s("summary",null,[i[4]||(i[4]=s("a",{id:"MolecularEvolution.lazyprep!-models",href:"#MolecularEvolution.lazyprep!-models"},[s("span",{class:"jlbinding"},"MolecularEvolution.lazyprep!")],-1)),i[5]||(i[5]=n()),e(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[7]||(i[7]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lazyprep!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, initial_message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{&lt;:Partition}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; partition_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message), direction</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LazyDirection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LazyUp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Extra, intermediate step of tree preparations between initializing messages across the tree and calling message passing algorithms with <code>LazyPartition</code>.</p><ol><li><p>Perform a <code>lazysort!</code> on tree to obtain the optimal tree for a lazy <code>felsenstein!</code> prop, or a <code>sample_down!</code>.</p></li><li><p>Fix <code>tree.parent_message</code> to an initial message.</p></li><li><p>Preallocate sufficiently many inner partitions needed for a <code>felsenstein!</code> prop, or a <code>sample_down!</code>.</p></li><li><p>Specialized preparations based on the direction of the operations (<code>forward!</code>, <code>backward!</code>). <code>LazyDown</code> or <code>LazyUp</code>.</p></li></ol><p>See also <code>LazyDown</code>, <code>LazyUp</code>.</p>',4)),e(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>i[6]||(i[6]=[s("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3da9349ef066bc4c0cea77e06324d516fdc7421b/src/models/lazy_models/lazy_partition.jl#L200-L210",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),s("details",u,[s("summary",null,[i[8]||(i[8]=s("a",{id:"MolecularEvolution.LazyUp-models",href:"#MolecularEvolution.LazyUp-models"},[s("span",{class:"jlbinding"},"MolecularEvolution.LazyUp")],-1)),i[9]||(i[9]=n()),e(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[11]||(i[11]=t('<p><strong>Constructor</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LazyUp()</span></span></code></pre></div><p><strong>Description</strong></p><p>Indicate that we want to do an upward pass, e.g. <code>felsenstein!</code>.</p>',4)),e(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>i[10]||(i[10]=[s("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3da9349ef066bc4c0cea77e06324d516fdc7421b/src/models/lazy_models/lazy_partition.jl#L42-L48",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),s("details",g,[s("summary",null,[i[12]||(i[12]=s("a",{id:"MolecularEvolution.LazyDown-models",href:"#MolecularEvolution.LazyDown-models"},[s("span",{class:"jlbinding"},"MolecularEvolution.LazyDown")],-1)),i[13]||(i[13]=n()),e(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[15]||(i[15]=t(`<p><strong>Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LazyDown(stores_obs)</span></span>
<span class="line"><span>LazyDown() = LazyDown(x::FelNode -&gt; true)</span></span></code></pre></div><p><strong>Description</strong></p><p>Indicate that we want to do a downward pass, e.g. <code>sample_down!</code>. The function passed to the constructor takes a <code>node::FelNode</code> as input and returns a <code>Bool</code> that decides if <code>node</code> stores its observations.</p>`,4)),e(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>i[14]||(i[14]=[s("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3da9349ef066bc4c0cea77e06324d516fdc7421b/src/models/lazy_models/lazy_partition.jl#L51-L59",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})])])}const F=l(h,[["render",y]]);export{w as __pageData,F as default};
