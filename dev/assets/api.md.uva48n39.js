import{_ as o,C as r,c as p,o as d,aA as n,j as i,G as l,a as t,w as a}from"./chunks/framework.Dyz83CXA.js";const _i=JSON.parse('{"title":"Full API","description":"","frontmatter":{},"headers":[],"relativePath":"api.md","filePath":"api.md","lastUpdated":null}'),h={name:"api.md"},u={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},M={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""},P={class:"jldocstring custom-block",open:""},N={class:"jldocstring custom-block",open:""},L={class:"jldocstring custom-block",open:""},V={class:"jldocstring custom-block",open:""},I={class:"jldocstring custom-block",open:""},R={class:"jldocstring custom-block",open:""},z={class:"jldocstring custom-block",open:""},G={class:"jldocstring custom-block",open:""},O={class:"jldocstring custom-block",open:""},q={class:"jldocstring custom-block",open:""},U={class:"jldocstring custom-block",open:""},W={class:"jldocstring custom-block",open:""},Q={class:"jldocstring custom-block",open:""},K={class:"jldocstring custom-block",open:""},Y={class:"jldocstring custom-block",open:""},H={class:"jldocstring custom-block",open:""},$={class:"jldocstring custom-block",open:""},J={class:"jldocstring custom-block",open:""},X={class:"jldocstring custom-block",open:""},Z={class:"jldocstring custom-block",open:""},ss={class:"jldocstring custom-block",open:""},is={class:"jldocstring custom-block",open:""},es={class:"jldocstring custom-block",open:""},ls={class:"jldocstring custom-block",open:""},ts={class:"jldocstring custom-block",open:""},as={class:"jldocstring custom-block",open:""},ns={class:"jldocstring custom-block",open:""},os={class:"jldocstring custom-block",open:""},rs={class:"jldocstring custom-block",open:""},ps={class:"jldocstring custom-block",open:""},ds={class:"jldocstring custom-block",open:""},hs={class:"jldocstring custom-block",open:""},us={class:"jldocstring custom-block",open:""},ks={class:"jldocstring custom-block",open:""},cs={class:"jldocstring custom-block",open:""},gs={class:"jldocstring custom-block",open:""},Es={class:"jldocstring custom-block",open:""},ys={class:"jldocstring custom-block",open:""},bs={class:"jldocstring custom-block",open:""},ms={class:"jldocstring custom-block",open:""},_s={class:"jldocstring custom-block",open:""},fs={class:"jldocstring custom-block",open:""},vs={class:"jldocstring custom-block",open:""},Fs={class:"jldocstring custom-block",open:""},Ts={class:"jldocstring custom-block",open:""},Ms={class:"jldocstring custom-block",open:""},Cs={class:"jldocstring custom-block",open:""},js={class:"jldocstring custom-block",open:""},As={class:"jldocstring custom-block",open:""},xs={class:"jldocstring custom-block",open:""},Ds={class:"jldocstring custom-block",open:""},ws={class:"jldocstring custom-block",open:""},Ss={class:"jldocstring custom-block",open:""},Bs={class:"jldocstring custom-block",open:""},Ps={class:"jldocstring custom-block",open:""},Ns={class:"jldocstring custom-block",open:""},Ls={class:"jldocstring custom-block",open:""},Vs={class:"jldocstring custom-block",open:""},Is={class:"jldocstring custom-block",open:""},Rs={class:"jldocstring custom-block",open:""},zs={class:"jldocstring custom-block",open:""},Gs={class:"jldocstring custom-block",open:""},Os={class:"jldocstring custom-block",open:""},qs={class:"jldocstring custom-block",open:""},Us={class:"jldocstring custom-block",open:""},Ws={class:"jldocstring custom-block",open:""},Qs={class:"jldocstring custom-block",open:""},Ks={class:"jldocstring custom-block",open:""},Ys={class:"jldocstring custom-block",open:""},Hs={class:"jldocstring custom-block",open:""},$s={class:"jldocstring custom-block",open:""},Js={class:"jldocstring custom-block",open:""},Xs={class:"jldocstring custom-block",open:""},Zs={class:"jldocstring custom-block",open:""},si={class:"jldocstring custom-block",open:""},ii={class:"jldocstring custom-block",open:""},ei={class:"jldocstring custom-block",open:""},li={class:"jldocstring custom-block",open:""},ti={class:"jldocstring custom-block",open:""},ai={class:"jldocstring custom-block",open:""},ni={class:"jldocstring custom-block",open:""},oi={class:"jldocstring custom-block",open:""},ri={class:"jldocstring custom-block",open:""},pi={class:"jldocstring custom-block",open:""},di={class:"jldocstring custom-block",open:""},hi={class:"jldocstring custom-block",open:""},ui={class:"jldocstring custom-block",open:""};function ki(ci,s,gi,Ei,yi,bi){const e=r("Badge");return d(),p("div",null,[s[444]||(s[444]=n('<h1 id="Full-API" tabindex="-1">Full API <a class="header-anchor" href="#Full-API" aria-label="Permalink to &quot;Full API {#Full-API}&quot;">​</a></h1><h2 id="index" tabindex="-1">Index <a class="header-anchor" href="#index" aria-label="Permalink to &quot;Index&quot;">​</a></h2><ul><li><a href="#MolecularEvolution.AbstractUpdate"><code>MolecularEvolution.AbstractUpdate</code></a></li><li><a href="#MolecularEvolution.BranchlengthSampler"><code>MolecularEvolution.BranchlengthSampler</code></a></li><li><a href="#MolecularEvolution.LazyDown"><code>MolecularEvolution.LazyDown</code></a></li><li><a href="#MolecularEvolution.LazyPartition"><code>MolecularEvolution.LazyPartition</code></a></li><li><a href="#MolecularEvolution.LazyUp"><code>MolecularEvolution.LazyUp</code></a></li><li><a href="#MolecularEvolution.StandardUpdate"><code>MolecularEvolution.StandardUpdate</code></a></li><li><a href="#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode"><code>Base.:==</code></a></li><li><a href="#MolecularEvolution.BayesUpdate-Tuple{}"><code>MolecularEvolution.BayesUpdate</code></a></li><li><a href="#MolecularEvolution.MaxLikUpdate-Tuple{}"><code>MolecularEvolution.MaxLikUpdate</code></a></li><li><a href="#MolecularEvolution.SWM_prob_grid-Union{Tuple{SWMPartition{PType}}, Tuple{PType}} where PType&lt;:MultiSitePartition"><code>MolecularEvolution.SWM_prob_grid</code></a></li><li><a href="#MolecularEvolution._mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any, Any}} where T&lt;:Function"><code>MolecularEvolution._mapreduce</code></a></li><li><a href="#MolecularEvolution.allocate!-Tuple{Any, Any}"><code>MolecularEvolution.allocate!</code></a></li><li><a href="#MolecularEvolution.backward!-Tuple{DiscretePartition, DiscretePartition, MolecularEvolution.PMatrixModel, FelNode}"><code>MolecularEvolution.backward!</code></a></li><li><a href="#MolecularEvolution.backward!"><code>MolecularEvolution.backward!</code></a></li><li><a href="#MolecularEvolution.bfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function"><code>MolecularEvolution.bfs_mapreduce</code></a></li><li><a href="#MolecularEvolution.branchlength_optim!-Tuple"><code>MolecularEvolution.branchlength_optim!</code></a></li><li><a href="#MolecularEvolution.branchlength_optim!"><code>MolecularEvolution.branchlength_optim!</code></a></li><li><a href="#MolecularEvolution.branchlength_update!-Tuple{MolecularEvolution.UnivariateModifier, FelNode, Any}"><code>MolecularEvolution.branchlength_update!</code></a></li><li><a href="#MolecularEvolution.brents_method_minimize-Tuple{Any, Real, Real, Any, Real}"><code>MolecularEvolution.brents_method_minimize</code></a></li><li><a href="#MolecularEvolution.cascading_max_state_dict"><code>MolecularEvolution.cascading_max_state_dict</code></a></li><li><a href="#MolecularEvolution.cascading_max_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.cascading_max_state_dict</code></a></li><li><a href="#MolecularEvolution.char_proportions-Tuple{Any, String}"><code>MolecularEvolution.char_proportions</code></a></li><li><a href="#MolecularEvolution.collect_leaf_dists-Tuple{Vector{&lt;:AbstractTreeNode}}"><code>MolecularEvolution.collect_leaf_dists</code></a></li><li><a href="#MolecularEvolution.colored_seq_draw-Tuple{Any, Any, AbstractString}"><code>MolecularEvolution.colored_seq_draw</code></a></li><li><a href="#MolecularEvolution.combine!-Tuple{DiscretePartition, DiscretePartition}"><code>MolecularEvolution.combine!</code></a></li><li><a href="#MolecularEvolution.combine!"><code>MolecularEvolution.combine!</code></a></li><li><a href="#MolecularEvolution.copy_tree"><code>MolecularEvolution.copy_tree</code></a></li><li><a href="#MolecularEvolution.deepequals-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode"><code>MolecularEvolution.deepequals</code></a></li><li><a href="#MolecularEvolution.dfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function"><code>MolecularEvolution.dfs_mapreduce</code></a></li><li><a href="#MolecularEvolution.discrete_name_color_dict-Tuple{AbstractTreeNode, Any}"><code>MolecularEvolution.discrete_name_color_dict</code></a></li><li><a href="#MolecularEvolution.draw_example_tree-Tuple{}"><code>MolecularEvolution.draw_example_tree</code></a></li><li><a href="#MolecularEvolution.endpoint_conditioned_sample_state_dict"><code>MolecularEvolution.endpoint_conditioned_sample_state_dict</code></a></li><li><a href="#MolecularEvolution.endpoint_conditioned_sample_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.endpoint_conditioned_sample_state_dict</code></a></li><li><a href="#MolecularEvolution.expected_subs_per_site-Tuple{Any, Any}"><code>MolecularEvolution.expected_subs_per_site</code></a></li><li><a href="#MolecularEvolution.felsenstein!-Tuple{FelNode, Any}"><code>MolecularEvolution.felsenstein!</code></a></li><li><a href="#MolecularEvolution.felsenstein_down!-Tuple{FelNode, Any}"><code>MolecularEvolution.felsenstein_down!</code></a></li><li><a href="#MolecularEvolution.felsenstein_roundtrip!-Tuple{FelNode, Any}"><code>MolecularEvolution.felsenstein_roundtrip!</code></a></li><li><a href="#MolecularEvolution.forward!"><code>MolecularEvolution.forward!</code></a></li><li><a href="#MolecularEvolution.forward!-Tuple{DiscretePartition, DiscretePartition, MolecularEvolution.PMatrixModel, FelNode}"><code>MolecularEvolution.forward!</code></a></li><li><a href="#MolecularEvolution.gappy_Q_from_symmetric_rate_matrix-Tuple{Any, Any, Any}"><code>MolecularEvolution.gappy_Q_from_symmetric_rate_matrix</code></a></li><li><a href="#MolecularEvolution.get_highlighter_legend-Tuple{Any}"><code>MolecularEvolution.get_highlighter_legend</code></a></li><li><a href="#MolecularEvolution.get_max_depth-Tuple{Any, Real}"><code>MolecularEvolution.get_max_depth</code></a></li><li><a href="#MolecularEvolution.get_phylo_tree-Tuple{FelNode}"><code>MolecularEvolution.get_phylo_tree</code></a></li><li><a href="#MolecularEvolution.get_phylo_tree"><code>MolecularEvolution.get_phylo_tree</code></a></li><li><a href="#MolecularEvolution.golden_section_maximize-Tuple{Any, Real, Real, Any, Real}"><code>MolecularEvolution.golden_section_maximize</code></a></li><li><a href="#MolecularEvolution.highlight_seq_draw-Tuple{Any, Any, AbstractString, Any, Any, Any}"><code>MolecularEvolution.highlight_seq_draw</code></a></li><li><a href="#MolecularEvolution.highlighter_tree_draw-NTuple{4, Any}"><code>MolecularEvolution.highlighter_tree_draw</code></a></li><li><a href="#MolecularEvolution.internal_message_init!-Tuple{FelNode, Partition}"><code>MolecularEvolution.internal_message_init!</code></a></li><li><a href="#MolecularEvolution.internal_message_init!-Tuple{FelNode, Vector{&lt;:Partition}}"><code>MolecularEvolution.internal_message_init!</code></a></li><li><a href="#MolecularEvolution.internal_nodes-Tuple{Any}"><code>MolecularEvolution.internal_nodes</code></a></li><li><a href="#MolecularEvolution.istreeconsistent-Tuple{T} where T&lt;:AbstractTreeNode"><code>MolecularEvolution.istreeconsistent</code></a></li><li><a href="#MolecularEvolution.ladder_tree_sim-Tuple{Any}"><code>MolecularEvolution.ladder_tree_sim</code></a></li><li><a href="#MolecularEvolution.lazyprep!-Tuple{FelNode, Vector{&lt;:Partition}}"><code>MolecularEvolution.lazyprep!</code></a></li><li><a href="#MolecularEvolution.lazysort!-Tuple{FelNode}"><code>MolecularEvolution.lazysort!</code></a></li><li><a href="#MolecularEvolution.leaf_distmat-Tuple{Any}"><code>MolecularEvolution.leaf_distmat</code></a></li><li><a href="#MolecularEvolution.leaf_names-Tuple{FelNode}"><code>MolecularEvolution.leaf_names</code></a></li><li><a href="#MolecularEvolution.leaf_samples-Tuple{FelNode}"><code>MolecularEvolution.leaf_samples</code></a></li><li><a href="#MolecularEvolution.leaves-Tuple{Any}"><code>MolecularEvolution.leaves</code></a></li><li><a href="#MolecularEvolution.linear_scale-NTuple{5, Any}"><code>MolecularEvolution.linear_scale</code></a></li><li><a href="#MolecularEvolution.log_likelihood-Tuple{FelNode, BranchModel}"><code>MolecularEvolution.log_likelihood</code></a></li><li><a href="#MolecularEvolution.log_likelihood!-Tuple{FelNode, Any}"><code>MolecularEvolution.log_likelihood!</code></a></li><li><a href="#MolecularEvolution.longest_path-Tuple{FelNode}"><code>MolecularEvolution.longest_path</code></a></li><li><a href="#MolecularEvolution.marginal_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.marginal_state_dict</code></a></li><li><a href="#MolecularEvolution.marginal_state_dict"><code>MolecularEvolution.marginal_state_dict</code></a></li><li><a href="#MolecularEvolution.matrix_for_display-Tuple{Any, Any}"><code>MolecularEvolution.matrix_for_display</code></a></li><li><a href="#MolecularEvolution.metropolis_sample-Tuple{AbstractUpdate, FelNode, Any, Any}"><code>MolecularEvolution.metropolis_sample</code></a></li><li><a href="#MolecularEvolution.metropolis_sample-Tuple{FelNode, Vector{&lt;:BranchModel}, Any}"><code>MolecularEvolution.metropolis_sample</code></a></li><li><a href="#MolecularEvolution.metropolis_step-Tuple{Function, Any, Any}"><code>MolecularEvolution.metropolis_step</code></a></li><li><a href="#MolecularEvolution.midpoint-Tuple{FelNode}"><code>MolecularEvolution.midpoint</code></a></li><li><a href="#MolecularEvolution.mix-Union{Tuple{SWMPartition{PType}}, Tuple{PType}} where PType&lt;:DiscretePartition"><code>MolecularEvolution.mix</code></a></li><li><a href="#MolecularEvolution.name2node_dict-Tuple{AbstractTreeNode}"><code>MolecularEvolution.name2node_dict</code></a></li><li><a href="#MolecularEvolution.newick-Tuple{AbstractTreeNode}"><code>MolecularEvolution.newick</code></a></li><li><a href="#MolecularEvolution.newick"><code>MolecularEvolution.newick</code></a></li><li><a href="#MolecularEvolution.nni_optim!-Tuple"><code>MolecularEvolution.nni_optim!</code></a></li><li><a href="#MolecularEvolution.nni_optim!"><code>MolecularEvolution.nni_optim!</code></a></li><li><a href="#MolecularEvolution.nni_update!-Tuple{Function, FelNode, Any}"><code>MolecularEvolution.nni_update!</code></a></li><li><a href="#MolecularEvolution.node_distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.node_distances</code></a></li><li><a href="#MolecularEvolution.node_names-Tuple{FelNode}"><code>MolecularEvolution.node_names</code></a></li><li><a href="#MolecularEvolution.node_samples-Tuple{FelNode}"><code>MolecularEvolution.node_samples</code></a></li><li><a href="#MolecularEvolution.nodes-Tuple{Any}"><code>MolecularEvolution.nodes</code></a></li><li><a href="#MolecularEvolution.nonreversibleQ-Tuple{Any}"><code>MolecularEvolution.nonreversibleQ</code></a></li><li><a href="#MolecularEvolution.parent_list-Tuple{FelNode}"><code>MolecularEvolution.parent_list</code></a></li><li><a href="#MolecularEvolution.partition2obs"><code>MolecularEvolution.partition2obs</code></a></li><li><a href="#MolecularEvolution.partition2obs-Tuple{DiscretePartition, String}"><code>MolecularEvolution.partition2obs</code></a></li><li><a href="#MolecularEvolution.plot_multiple_trees-Tuple{Any, Any}"><code>MolecularEvolution.plot_multiple_trees</code></a></li><li><a href="#MolecularEvolution.plot_multiple_trees"><code>MolecularEvolution.plot_multiple_trees</code></a></li><li><a href="#MolecularEvolution.populate_tree!-Tuple{FelNode, Partition, Any, Any}"><code>MolecularEvolution.populate_tree!</code></a></li><li><a href="#MolecularEvolution.populate_tree!"><code>MolecularEvolution.populate_tree!</code></a></li><li><a href="#MolecularEvolution.promote_internal-Tuple{FelNode}"><code>MolecularEvolution.promote_internal</code></a></li><li><a href="#MolecularEvolution.quadratic_CI-Tuple{Vector, Vector}"><code>MolecularEvolution.quadratic_CI</code></a></li><li><a href="#MolecularEvolution.quadratic_CI-Tuple{Function, Vector, Int64}"><code>MolecularEvolution.quadratic_CI</code></a></li><li><a href="#MolecularEvolution.read_fasta-Tuple{String}"><code>MolecularEvolution.read_fasta</code></a></li><li><a href="#MolecularEvolution.read_fasta"><code>MolecularEvolution.read_fasta</code></a></li><li><a href="#MolecularEvolution.read_newick_tree"><code>MolecularEvolution.read_newick_tree</code></a></li><li><a href="#MolecularEvolution.read_newick_tree-Tuple{String}"><code>MolecularEvolution.read_newick_tree</code></a></li><li><a href="#MolecularEvolution.reversibleQ-Tuple{Any, Any}"><code>MolecularEvolution.reversibleQ</code></a></li><li><a href="#MolecularEvolution.reversibleQ"><code>MolecularEvolution.reversibleQ</code></a></li><li><a href="#MolecularEvolution.root2tip_distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.root2tip_distances</code></a></li><li><a href="#MolecularEvolution.root_optim!-Tuple{FelNode, Any}"><code>MolecularEvolution.root_optim!</code></a></li><li><a href="#MolecularEvolution.root_update!-Tuple{RootUpdate, FelNode, Any}"><code>MolecularEvolution.root_update!</code></a></li><li><a href="#MolecularEvolution.sample_down!-Tuple{FelNode, Any, Any}"><code>MolecularEvolution.sample_down!</code></a></li><li><a href="#MolecularEvolution.sample_down!"><code>MolecularEvolution.sample_down!</code></a></li><li><a href="#MolecularEvolution.sample_from_message!-Tuple{Vector{&lt;:Partition}}"><code>MolecularEvolution.sample_from_message!</code></a></li><li><a href="#MolecularEvolution.savefig_tweakSVG-Tuple{Any, Context}"><code>MolecularEvolution.savefig_tweakSVG</code></a></li><li><a href="#MolecularEvolution.savefig_tweakSVG"><code>MolecularEvolution.savefig_tweakSVG</code></a></li><li><a href="#MolecularEvolution.savefig_tweakSVG-Tuple{Any, Plots.Plot}"><code>MolecularEvolution.savefig_tweakSVG</code></a></li><li><a href="#MolecularEvolution.shortest_path_between_nodes-Tuple{FelNode, FelNode}"><code>MolecularEvolution.shortest_path_between_nodes</code></a></li><li><a href="#MolecularEvolution.sibling_inds-Tuple{AbstractTreeNode}"><code>MolecularEvolution.sibling_inds</code></a></li><li><a href="#MolecularEvolution.siblings-Tuple{AbstractTreeNode}"><code>MolecularEvolution.siblings</code></a></li><li><a href="#MolecularEvolution.sim_tree"><code>MolecularEvolution.sim_tree</code></a></li><li><a href="#MolecularEvolution.sim_tree-Tuple{}"><code>MolecularEvolution.sim_tree</code></a></li><li><a href="#MolecularEvolution.sim_tree-Tuple{Int64, Any, Any}"><code>MolecularEvolution.sim_tree</code></a></li><li><a href="#MolecularEvolution.simple_radial_tree_plot-Tuple{FelNode}"><code>MolecularEvolution.simple_radial_tree_plot</code></a></li><li><a href="#MolecularEvolution.simple_tree_draw-Tuple{FelNode}"><code>MolecularEvolution.simple_tree_draw</code></a></li><li><a href="#MolecularEvolution.standard_tree_sim-Tuple{Any}"><code>MolecularEvolution.standard_tree_sim</code></a></li><li><a href="#MolecularEvolution.total_LL-Tuple{Partition}"><code>MolecularEvolution.total_LL</code></a></li><li><a href="#MolecularEvolution.tree2distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.tree2distances</code></a></li><li><a href="#MolecularEvolution.tree2shared_branch_lengths-Tuple{AbstractTreeNode}"><code>MolecularEvolution.tree2shared_branch_lengths</code></a></li><li><a href="#MolecularEvolution.tree_draw"><code>MolecularEvolution.tree_draw</code></a></li><li><a href="#MolecularEvolution.tree_draw-Tuple{FelNode}"><code>MolecularEvolution.tree_draw</code></a></li><li><a href="#MolecularEvolution.tree_polish!-Tuple{Any, Any}"><code>MolecularEvolution.tree_polish!</code></a></li><li><a href="#MolecularEvolution.tree_polish!"><code>MolecularEvolution.tree_polish!</code></a></li><li><a href="#MolecularEvolution.unc2probvec"><code>MolecularEvolution.unc2probvec</code></a></li><li><a href="#MolecularEvolution.unc2probvec-Tuple{Any}"><code>MolecularEvolution.unc2probvec</code></a></li><li><a href="#MolecularEvolution.univariate_maximize-Tuple{Any, Real, Real, Any, BrentsMethodOpt, Real}"><code>MolecularEvolution.univariate_maximize</code></a></li><li><a href="#MolecularEvolution.univariate_maximize-Tuple{Any, Real, Real, Any, GoldenSectionOpt, Real}"><code>MolecularEvolution.univariate_maximize</code></a></li><li><a href="#MolecularEvolution.univariate_sampler-Tuple{Any, BranchlengthSampler, Any}"><code>MolecularEvolution.univariate_sampler</code></a></li><li><a href="#MolecularEvolution.values_from_phylo_tree"><code>MolecularEvolution.values_from_phylo_tree</code></a></li><li><a href="#MolecularEvolution.values_from_phylo_tree-Tuple{Any, Any}"><code>MolecularEvolution.values_from_phylo_tree</code></a></li><li><a href="#MolecularEvolution.weightEM-Tuple{Matrix{Float64}, Any}"><code>MolecularEvolution.weightEM</code></a></li><li><a href="#MolecularEvolution.write_fasta"><code>MolecularEvolution.write_fasta</code></a></li><li><a href="#MolecularEvolution.write_fasta-Tuple{String, Vector{String}}"><code>MolecularEvolution.write_fasta</code></a></li><li><a href="#MolecularEvolution.write_nexus-Tuple{String, FelNode}"><code>MolecularEvolution.write_nexus</code></a></li><li><a href="#MolecularEvolution.write_nexus"><code>MolecularEvolution.write_nexus</code></a></li></ul><h2 id="docstrings" tabindex="-1">Docstrings <a class="header-anchor" href="#docstrings" aria-label="Permalink to &quot;Docstrings&quot;">​</a></h2>',4)),i("details",u,[i("summary",null,[s[0]||(s[0]=i("a",{id:"MolecularEvolution.AbstractUpdate",href:"#MolecularEvolution.AbstractUpdate"},[i("span",{class:"jlbinding"},"MolecularEvolution.AbstractUpdate")],-1)),s[1]||(s[1]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[3]||(s[3]=n(`<p><strong>Summary</strong></p><p><code>abstract type AbstractUpdate &lt;: Function</code></p><p>A callable type that typically takes <code>(tree::FelNode, models; partition_list=1:length(tree.message))</code>, updates <code>tree</code> and <code>models</code>, and returns the updated <code>tree</code> and <code>models</code>.</p><p><strong>Example</strong></p><p>Define a new subtype, where <code>foo</code> and <code>bar</code> are arbitrary updating functions</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MyUpdate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractUpdate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (update</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models; partition_list</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    tree, models </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree, models, partition_list</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">partition_list)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    tree, models </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> BayesUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nni</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(tree, models, partition_list</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">partition_list)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    tree, models </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree, models, partition_list</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">partition_list)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tree, models</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>See also: <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.StandardUpdate"><code>StandardUpdate</code></a></p>`,7)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[2]||(s[2]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/AbstractUpdate.jl#L1-L20",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",k,[i("summary",null,[s[4]||(s[4]=i("a",{id:"MolecularEvolution.BranchlengthSampler",href:"#MolecularEvolution.BranchlengthSampler"},[i("span",{class:"jlbinding"},"MolecularEvolution.BranchlengthSampler")],-1)),s[5]||(s[5]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[7]||(s[7]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BranchlengthSampler</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A type that allows you to specify a additive proposal </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> the log domain and a prior distrubution over the log of the branchlengths. It also stores </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`acc_ratio`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> which is a tuple of </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`(ratio, total, #acceptances)`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `ratio::Float64`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> is the acceptance ratio, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`total::Int64`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> is the total number of proposals, and </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`#acceptances::Int64`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> is the number of acceptances.</span></span></code></pre></div>',1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[6]||(s[6]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/simple_sample.jl#L6-L10",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",c,[i("summary",null,[s[8]||(s[8]=i("a",{id:"MolecularEvolution.LazyDown",href:"#MolecularEvolution.LazyDown"},[i("span",{class:"jlbinding"},"MolecularEvolution.LazyDown")],-1)),s[9]||(s[9]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[11]||(s[11]=n(`<p><strong>Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LazyDown(stores_obs)</span></span>
<span class="line"><span>LazyDown() = LazyDown(x::FelNode -&gt; true)</span></span></code></pre></div><p><strong>Description</strong></p><p>Indicate that we want to do a downward pass, e.g. <code>sample_down!</code>. The function passed to the constructor takes a <code>node::FelNode</code> as input and returns a <code>Bool</code> that decides if <code>node</code> stores its observations.</p>`,4)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[10]||(s[10]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/lazy_models/lazy_partition.jl#L51-L59",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",g,[i("summary",null,[s[12]||(s[12]=i("a",{id:"MolecularEvolution.LazyPartition",href:"#MolecularEvolution.LazyPartition"},[i("span",{class:"jlbinding"},"MolecularEvolution.LazyPartition")],-1)),s[13]||(s[13]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[15]||(s[15]=n('<p><strong>Constructor</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LazyPartition{PType}()</span></span></code></pre></div><p>Initialize an empty <code>LazyPartition</code> that is meant for wrapping a partition of type <code>PType</code>.</p><p><strong>Description</strong></p><p>With this data structure, you can wrap a partition of choice. The idea is that in some message passing algorithms, there is only a wave of partitions which need to actualize. For instance, a wave following a root-leaf path, or a depth-first traversal. In which case, we can be more economical with our memory consumption. With a worst case memory complexity of O(log(n)), where n is the number of nodes, functionality is provided for:</p><ul><li><p><code>log_likelihood!</code></p></li><li><p><code>felsenstein!</code></p></li><li><p><code>sample_down!</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>For successive <code>felsenstein!</code> calls, we need to extract the information at the root somehow after each call. This can be done with e.g. <code>total_LL</code> or <code>site_LLs</code>.</p></div><p><strong>Further requirements</strong></p><p>Suppose you want to wrap a partition of <code>PType</code> with <code>LazyPartition</code>:</p><ul><li><p>If you&#39;re calling <code>log_likelihood!</code> and <code>felsenstein!</code>:</p><ul><li><code>obs2partition!(partition::PType, obs)</code> that transforms an observation to a partition.</li></ul></li><li><p>If you&#39;re calling <code>sample_down!</code>:</p><ul><li><code>partition2obs(partition::PType)</code> that returns the most likely state from a partition, inverts <code>obs2partition!</code>.</li></ul></li></ul>',10)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[14]||(s[14]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/lazy_models/lazy_partition.jl#L2-L25",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",E,[i("summary",null,[s[16]||(s[16]=i("a",{id:"MolecularEvolution.LazyUp",href:"#MolecularEvolution.LazyUp"},[i("span",{class:"jlbinding"},"MolecularEvolution.LazyUp")],-1)),s[17]||(s[17]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[19]||(s[19]=n('<p><strong>Constructor</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LazyUp()</span></span></code></pre></div><p><strong>Description</strong></p><p>Indicate that we want to do an upward pass, e.g. <code>felsenstein!</code>.</p>',4)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[18]||(s[18]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/lazy_models/lazy_partition.jl#L42-L48",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",y,[i("summary",null,[s[20]||(s[20]=i("a",{id:"MolecularEvolution.StandardUpdate",href:"#MolecularEvolution.StandardUpdate"},[i("span",{class:"jlbinding"},"MolecularEvolution.StandardUpdate")],-1)),s[21]||(s[21]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[23]||(s[23]=n(`<p><strong>Summary</strong></p><p><code>struct StandardUpdate &lt;: AbstractUpdate</code></p><p>A standard update can be a family of calls to <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.nni_update!-Tuple{Function, FelNode, Any}"><code>nni_update!</code></a>, <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.branchlength_update!-Tuple{MolecularEvolution.UnivariateModifier, FelNode, Any}"><code>branchlength_update!</code></a>, <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.root_update!-Tuple{RootUpdate, FelNode, Any}"><code>root_update!</code></a>, and model updates.</p><p><strong>Constructor</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>StandardUpdate(</span></span>
<span class="line"><span>    nni::Int,</span></span>
<span class="line"><span>    branchlength::Int,</span></span>
<span class="line"><span>    root::Int,</span></span>
<span class="line"><span>    models::Int,</span></span>
<span class="line"><span>    nni_selection::Function,</span></span>
<span class="line"><span>    branchlength_modifier::UnivariateModifier,</span></span>
<span class="line"><span>    root_update::RootUpdate,</span></span>
<span class="line"><span>    models_update::ModelsUpdate</span></span>
<span class="line"><span>)</span></span></code></pre></div><p><strong>Arguments</strong></p><ul><li><p><code>nni::Int</code>: the number of times to update the tree by <code>nni_update!</code></p></li><li><p><code>branchlength::Int</code>: the number of times to update the tree by <code>branchlength_update!</code></p></li><li><p><code>root::Int</code>: the number of times to update the tree by <code>root_update!</code></p></li><li><p><code>models::Int</code>: the number of times to update the model</p></li><li><p><code>nni_selection::Function</code>: the function that selects between nni configurations</p></li><li><p><code>branchlength_modifier::UnivariateModifier</code>: the modifier to update a branchlength by <code>branchlength_update!</code></p></li><li><p><code>root_update::RootUpdate</code>: updates the root by <code>root_update!</code></p></li><li><p><code>models_update::ModelsUpdate</code>: updates the model parameters</p></li></ul><p>See also: <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.BayesUpdate-Tuple{}"><code>BayesUpdate</code></a>, <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.MaxLikUpdate-Tuple{}"><code>MaxLikUpdate</code></a></p>`,8)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[22]||(s[22]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/AbstractUpdate.jl#L23-L51",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",b,[i("summary",null,[s[24]||(s[24]=i("a",{id:"Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractTreeNode",href:"#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractTreeNode"},[i("span",{class:"jlbinding"},"Base.:==")],-1)),s[25]||(s[25]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[27]||(s[27]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t1, t2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Defaults to pointer equality</span></span></code></pre></div>`,1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[26]||(s[26]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/AbstractTreeNode.jl#L78-L81",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",m,[i("summary",null,[s[28]||(s[28]=i("a",{id:"MolecularEvolution.BayesUpdate-Tuple{}",href:"#MolecularEvolution.BayesUpdate-Tuple{}"},[i("span",{class:"jlbinding"},"MolecularEvolution.BayesUpdate")],-1)),s[29]||(s[29]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[31]||(s[31]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BayesUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nni </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    branchlength </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    models </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    branchlength_sampler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnivariateSampler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> BranchlengthSampler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Normal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Normal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root_sampler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RootSample</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> StandardRootSample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    models_sampler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ModelsUpdate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> StandardModelsUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convenience constructor for <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.StandardUpdate"><code>StandardUpdate</code></a>. The <code>nni_selection</code> is fixed to <code>softmax_sampler</code>. This constructor provides Bayesian updates by sampling from the posterior distribution.</p>`,2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[30]||(s[30]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/AbstractUpdate.jl#L63-L79",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",_,[i("summary",null,[s[32]||(s[32]=i("a",{id:"MolecularEvolution.MaxLikUpdate-Tuple{}",href:"#MolecularEvolution.MaxLikUpdate-Tuple{}"},[i("span",{class:"jlbinding"},"MolecularEvolution.MaxLikUpdate")],-1)),s[33]||(s[33]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[35]||(s[35]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MaxLikUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nni </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    branchlength </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    models </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    branchlength_optimizer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnivariateOpt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GoldenSectionOpt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root_optimizer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> StandardRootOpt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    models_optimizer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ModelUpdate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> StandardModelUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convenience constructor for <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.StandardUpdate"><code>StandardUpdate</code></a>. The <code>nni_selection</code> is fixed to <code>argmax</code>. This constructor provides Maximum Likelihood updates by optimizing parameters.</p>`,2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[34]||(s[34]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/AbstractUpdate.jl#L102-L115",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",f,[i("summary",null,[s[36]||(s[36]=i("a",{id:"MolecularEvolution.SWM_prob_grid-Union{Tuple{SWMPartition{PType}}, Tuple{PType}} where PType<:MultiSitePartition",href:"#MolecularEvolution.SWM_prob_grid-Union{Tuple{SWMPartition{PType}}, Tuple{PType}} where PType<:MultiSitePartition"},[i("span",{class:"jlbinding"},"MolecularEvolution.SWM_prob_grid")],-1)),s[37]||(s[37]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[39]||(s[39]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SWM_prob_grid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(part</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SWMPartition{PType}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {PType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MultiSitePartition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Returns a matrix of probabilities for each site, for each model (in the probability domain - not logged!) as well as the log probability offsets</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[38]||(s[38]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/compound_models/swm.jl#L131-L135",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",v,[i("summary",null,[s[40]||(s[40]=i("a",{id:"MolecularEvolution._mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any, Any}} where T<:Function",href:"#MolecularEvolution._mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any, Any}} where T<:Function"},[i("span",{class:"jlbinding"},"MolecularEvolution._mapreduce")],-1)),s[41]||(s[41]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[43]||(s[43]=i("p",null,"Internal function. Helper for bfs_mapreduce and dfs_mapreduce",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[42]||(s[42]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/base_tree_utils.jl#L1",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",F,[i("summary",null,[s[44]||(s[44]=i("a",{id:"MolecularEvolution.allocate!-Tuple{Any, Any}",href:"#MolecularEvolution.allocate!-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.allocate!")],-1)),s[45]||(s[45]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[47]||(s[47]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">allocate!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree, partition_or_message)</span></span></code></pre></div><p>Allocates initial messages for all nodes in the tree, copying the passed-in message template. If passed a partition, then this will assume the message template is a vector containing just that partition.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[46]||(s[46]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/simple_interface.jl#L38-L43",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",T,[i("summary",null,[s[48]||(s[48]=i("a",{id:"MolecularEvolution.backward!-Tuple{DiscretePartition, DiscretePartition, MolecularEvolution.PMatrixModel, FelNode}",href:"#MolecularEvolution.backward!-Tuple{DiscretePartition, DiscretePartition, MolecularEvolution.PMatrixModel, FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.backward!")],-1)),s[49]||(s[49]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[51]||(s[51]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">backward!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dest</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BranchModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Propagate the source partition backwards along the branch to the destination partition, under the model. Note: You should overload this for your own BranchModel types.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[50]||(s[50]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/discrete_models/pmatrix_models/pmatrix_models.jl#L5-L10",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",M,[i("summary",null,[s[52]||(s[52]=i("a",{id:"MolecularEvolution.bfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T<:Function",href:"#MolecularEvolution.bfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T<:Function"},[i("span",{class:"jlbinding"},"MolecularEvolution.bfs_mapreduce")],-1)),s[53]||(s[53]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[55]||(s[55]=i("p",null,"Performs a BFS map-reduce over the tree, starting at a given node For each node, map_reduce is called as: map_reduce(curr_node::FelNode, prev_node::FelNode, aggregator) where prev_node is the previous node visited on the path from the start node to the current node It is expected to update the aggregator, and not return anything.",-1)),s[56]||(s[56]=i("p",null,"Not exactly conventional map-reduce, as map-reduce calls may rely on state in the aggregator added by map-reduce calls on other nodes visited earlier.",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[54]||(s[54]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/base_tree_utils.jl#L27-L36",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",C,[i("summary",null,[s[57]||(s[57]=i("a",{id:"MolecularEvolution.branchlength_optim!-Tuple",href:"#MolecularEvolution.branchlength_optim!-Tuple"},[i("span",{class:"jlbinding"},"MolecularEvolution.branchlength_optim!")],-1)),s[58]||(s[58]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[60]||(s[60]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">branchlength_optim!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models;  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Uses golden section search, or optionally Brent&#39;s method, to optimize all branches recursively, maintaining the integrity of the messages. Requires felsenstein!() to have been run first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>partition_list=nothing</code>: (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over (but you probably want to optimize branch lengths with all models, the default option).</p></li><li><p><code>tol=1e-5</code>: absolute tolerance for the <code>bl_optimizer</code>.</p></li><li><p><code>bl_optimizer::UnivariateModifier=GoldenSectionOpt()</code>: the algorithm used to optimize the log likelihood of a branch length. In addition to golden section search, Brent&#39;s method can be used by setting <code>bl_optimizer=BrentsMethodOpt()</code>.</p></li><li><p><code>sort_tree=false</code>: determines if a <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.lazysort!-Tuple{FelNode}"><code>lazysort!</code></a> will be performed, which can reduce the amount of temporary messages that has to be initialized.</p></li><li><p><code>traversal=Iterators.reverse</code>: a function that determines the traversal, permutes an iterable.</p></li><li><p><code>shuffle=false</code>: do a randomly shuffled traversal, overrides <code>traversal</code>.</p></li></ul>',4)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[59]||(s[59]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/branchlength_optim.jl#L189-L204",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",j,[i("summary",null,[s[61]||(s[61]=i("a",{id:"MolecularEvolution.branchlength_update!-Tuple{MolecularEvolution.UnivariateModifier, FelNode, Any}",href:"#MolecularEvolution.branchlength_update!-Tuple{MolecularEvolution.UnivariateModifier, FelNode, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.branchlength_update!")],-1)),s[62]||(s[62]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[64]||(s[64]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">branchlength_update!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bl_modifier</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnivariateModifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A more general version of <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/optimization#MolecularEvolution.branchlength_optim!"><code>branchlength_optim!</code></a>. Here <code>bl_modifier</code> can be either an optimizer or a sampler (or more generally, a UnivariateModifier).</p><p><strong>Keyword Arguments</strong></p><p>See <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/optimization#MolecularEvolution.branchlength_optim!"><code>branchlength_optim!</code></a>.</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p><code>bl_modifier</code> is a positional argument here, and not a keyword argument.</p></div>',5)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[63]||(s[63]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/branchlength_optim.jl#L154-L163",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",A,[i("summary",null,[s[65]||(s[65]=i("a",{id:"MolecularEvolution.brents_method_minimize-Tuple{Any, Real, Real, Any, Real}",href:"#MolecularEvolution.brents_method_minimize-Tuple{Any, Real, Real, Any, Real}"},[i("span",{class:"jlbinding"},"MolecularEvolution.brents_method_minimize")],-1)),s[66]||(s[66]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[68]||(s[68]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">brents_method_minimize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, transform, t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; ε</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sqrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">eps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()))</span></span></code></pre></div><p>Brent&#39;s method for minimization.</p><p>Given a function f with a single local minimum in the interval (a,b), Brent&#39;s method returns an approximation of the x-value that minimizes f to an accuaracy between 2tol and 3tol, where tol is a combination of a relative and an absolute tolerance, tol := ε|x| + t. ε should be no smaller <code>2*eps</code>, and preferably not much less than <code>sqrt(eps)</code>, which is also the default value. eps is defined here as the machine epsilon in double precision. t should be positive.</p><p>The method combines the stability of a Golden Section Search and the superlinear convergence Successive Parabolic Interpolation has under certain conditions. The method never converges much slower than a Fibonacci search and for a sufficiently well-behaved f, convergence can be exptected to be superlinear, with an order that&#39;s usually atleast 1.3247...</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> exp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f (generic </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> with </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> method)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> brents_method_minimize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, identity, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e-7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5885327257940255</span></span></code></pre></div><p>From: Richard P. Brent, &quot;Algorithms for Minimization without Derivatives&quot; (1973). Chapter 5.</p>`,7)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[67]||(s[67]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/simple_optim.jl#L110-L139",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",x,[i("summary",null,[s[69]||(s[69]=i("a",{id:"MolecularEvolution.cascading_max_state_dict-Tuple{FelNode, Any}",href:"#MolecularEvolution.cascading_max_state_dict-Tuple{FelNode, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.cascading_max_state_dict")],-1)),s[70]||(s[70]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[72]||(s[72]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cascading_max_state_dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model; partition_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message), node_message_dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict{FelNode,Vector{&lt;:Partition}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Takes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode-&gt;Array{&lt;:BranchModel}), and returns a dictionary mapping nodes to their inferred ancestors under the following scheme: the state that maximizes the marginal likelihood is selected at the root, and then, for each node, the maximum likelihood state is selected conditioned on the maximized state of the parent node and the observations of all descendents. A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you&#39;re running this over and over.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[71]||(s[71]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/ancestors.jl#L175-L182",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",D,[i("summary",null,[s[73]||(s[73]=i("a",{id:"MolecularEvolution.char_proportions-Tuple{Any, String}",href:"#MolecularEvolution.char_proportions-Tuple{Any, String}"},[i("span",{class:"jlbinding"},"MolecularEvolution.char_proportions")],-1)),s[74]||(s[74]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[76]||(s[76]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">char_proportions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(seqs, alphabet</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Takes a vector of sequences and returns a vector of the proportion of each character across all sequences. An example <code>alphabet</code> argument is <code>MolecularEvolution.AAstring</code>.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[75]||(s[75]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/discrete_models/utils/matrix_helpers.jl#L87-L92",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",w,[i("summary",null,[s[77]||(s[77]=i("a",{id:"MolecularEvolution.collect_leaf_dists-Tuple{Vector{<:AbstractTreeNode}}",href:"#MolecularEvolution.collect_leaf_dists-Tuple{Vector{<:AbstractTreeNode}}"},[i("span",{class:"jlbinding"},"MolecularEvolution.collect_leaf_dists")],-1)),s[78]||(s[78]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[80]||(s[80]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">collect_leaf_dists</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(trees</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{&lt;:AbstractTreeNode}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Returns a list of distance matrices containing the distance between the leaf nodes, which can be used to assess mixing.</span></span></code></pre></div>`,1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[79]||(s[79]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/bayes/sampling.jl#L137-L141",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",S,[i("summary",null,[s[81]||(s[81]=i("a",{id:"MolecularEvolution.colored_seq_draw-Tuple{Any, Any, AbstractString}",href:"#MolecularEvolution.colored_seq_draw-Tuple{Any, Any, AbstractString}"},[i("span",{class:"jlbinding"},"MolecularEvolution.colored_seq_draw")],-1)),s[82]||(s[82]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[84]||(s[84]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">colored_seq_draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y, str</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; color_dict</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), font_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pt, posx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hcenter, posy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vcenter)</span></span></code></pre></div><p>Draw an arbitrary sequence. <code>color_dict</code> gives a mapping from characters to colors (default black). Default options for nucleotide colorings and amino acid colorings are given in the constants <code>NUC_COLORS</code> and <code>AA_COLORS</code>. This can be used along with <code>compose_dict</code> for drawing sequences at nodes in a tree (see <code>tree_draw</code>). Returns a Compose container.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[83]||(s[83]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/tree_compose.jl#L696-L704",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",B,[i("summary",null,[s[85]||(s[85]=i("a",{id:"MolecularEvolution.combine!-Tuple{DiscretePartition, DiscretePartition}",href:"#MolecularEvolution.combine!-Tuple{DiscretePartition, DiscretePartition}"},[i("span",{class:"jlbinding"},"MolecularEvolution.combine!")],-1)),s[86]||(s[86]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[88]||(s[88]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">combine!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dest</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> P</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Partition</span></span></code></pre></div><p>Combines evidence from two partitions of the same type, storing the result in dest. Note: You should overload this for your own Partititon types.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[87]||(s[87]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/discrete_models/discrete_partitions.jl#L124-L129",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",P,[i("summary",null,[s[89]||(s[89]=i("a",{id:"MolecularEvolution.copy_tree",href:"#MolecularEvolution.copy_tree"},[i("span",{class:"jlbinding"},"MolecularEvolution.copy_tree")],-1)),s[90]||(s[90]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[92]||(s[92]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> copy_tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, shallow_copy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Returns an untangled copy of the tree. Optionally, the flag </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`shallow_copy`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> can be used to obtain a copy of the tree with only the names and branchlengths.</span></span></code></pre></div>',1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[91]||(s[91]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/FelNode.jl#L102-L107",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",N,[i("summary",null,[s[93]||(s[93]=i("a",{id:"MolecularEvolution.deepequals-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractTreeNode",href:"#MolecularEvolution.deepequals-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractTreeNode"},[i("span",{class:"jlbinding"},"MolecularEvolution.deepequals")],-1)),s[94]||(s[94]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[96]||(s[96]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">deepequals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t1, t2)</span></span></code></pre></div><p>Checks whether two trees are equal by recursively calling this on all fields, except <code>:parent</code>, in order to prevent cycles. In order to ensure that the <code>:parent</code> field is not hiding something different on both trees, ensure that each is consistent first (see: <code>istreeconsistent</code>).</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[95]||(s[95]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/AbstractTreeNode.jl#L88-L93",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",L,[i("summary",null,[s[97]||(s[97]=i("a",{id:"MolecularEvolution.dfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T<:Function",href:"#MolecularEvolution.dfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T<:Function"},[i("span",{class:"jlbinding"},"MolecularEvolution.dfs_mapreduce")],-1)),s[98]||(s[98]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[100]||(s[100]=i("p",null,"Performs a DFS map-reduce over the tree, starting at a given node See bfs_mapreduce for more details.",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[99]||(s[99]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/base_tree_utils.jl#L46-L49",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",V,[i("summary",null,[s[101]||(s[101]=i("a",{id:"MolecularEvolution.discrete_name_color_dict-Tuple{AbstractTreeNode, Any}",href:"#MolecularEvolution.discrete_name_color_dict-Tuple{AbstractTreeNode, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.discrete_name_color_dict")],-1)),s[102]||(s[102]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[104]||(s[104]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">discrete_name_color_dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractTreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,tag_func; rainbow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, scramble </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, darken </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, col_seed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Takes a tree and a tag_func, which converts the leaf label into a category (ie. there should be &lt;20 of these), and returns a color dictionary that can be used to color the leaves or bubbles.</p><p>Example tag_func: function tag_func(nam::String) return split(nam,&quot;_&quot;)[1] end</p><p>For prettier colors, but less discrimination: rainbow = true To randomize the rainbow color assignment: scramble = true col_seed is currently set to white, and excluded from the list of colors, to make them more visible.</p><p>Consider making your own version of this function to customize colors as you see fit.</p><p>Example use: num_leaves = 50 Ne_func(t) = 1*(e^-t).+5.0 newt = sim_tree(num_leaves,Ne_func,1.0,nstart = rand(1:num_leaves)); newt = ladderize(newt) tag_func(nam) = mod(sum(Int.(collect(nam))),7) dic = discrete_name_color_dict(newt,tag_func,rainbow = true); tree_draw(newt,line_width = 0.5mm,label_color_dict = dic)</p>',6)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[103]||(s[103]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/tree_compose.jl#L511-L536",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",I,[i("summary",null,[s[105]||(s[105]=i("a",{id:"MolecularEvolution.draw_example_tree-Tuple{}",href:"#MolecularEvolution.draw_example_tree-Tuple{}"},[i("span",{class:"jlbinding"},"MolecularEvolution.draw_example_tree")],-1)),s[106]||(s[106]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[108]||(s[108]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">draw_example_tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(num_leaves </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Draws a tree and shows the code that draws it.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[107]||(s[107]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/tree_compose.jl#L576-L580",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",R,[i("summary",null,[s[109]||(s[109]=i("a",{id:"MolecularEvolution.endpoint_conditioned_sample_state_dict-Tuple{FelNode, Any}",href:"#MolecularEvolution.endpoint_conditioned_sample_state_dict-Tuple{FelNode, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.endpoint_conditioned_sample_state_dict")],-1)),s[110]||(s[110]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[112]||(s[112]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">endpoint_conditioned_sample_state_dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model; partition_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message), node_message_dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict{FelNode,Vector{&lt;:Partition}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Takes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode-&gt;Array{&lt;:BranchModel}), and draws samples under the model conditions on the leaf observations. These samples are stored in the node_message_dict, which is returned. A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you&#39;re running this over and over.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[111]||(s[111]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/ancestors.jl#L208-L214",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",z,[i("summary",null,[s[113]||(s[113]=i("a",{id:"MolecularEvolution.expected_subs_per_site-Tuple{Any, Any}",href:"#MolecularEvolution.expected_subs_per_site-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.expected_subs_per_site")],-1)),s[114]||(s[114]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[116]||(s[116]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">expected_subs_per_site</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Q,mu)</span></span></code></pre></div><p>Takes a rate matrix Q and an equilibrium frequency vector, and calculates the expected number of substitutions per site.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[115]||(s[115]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/misc.jl#L144-L148",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",G,[i("summary",null,[s[117]||(s[117]=i("a",{id:"MolecularEvolution.felsenstein!-Tuple{FelNode, Any}",href:"#MolecularEvolution.felsenstein!-Tuple{FelNode, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.felsenstein!")],-1)),s[118]||(s[118]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[120]||(s[120]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">felsenstein!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models; partition_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Should usually be called on the root of the tree. Propagates Felsenstein pass up from the tips to the root. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[119]||(s[119]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/felsenstein.jl#L1-L8",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",O,[i("summary",null,[s[121]||(s[121]=i("a",{id:"MolecularEvolution.felsenstein_down!-Tuple{FelNode, Any}",href:"#MolecularEvolution.felsenstein_down!-Tuple{FelNode, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.felsenstein_down!")],-1)),s[122]||(s[122]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[124]||(s[124]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">felsenstein_down!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models; partition_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message), temp_message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> copy_message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message))</span></span></code></pre></div><p>Should usually be called on the root of the tree. Propagates Felsenstein pass down from the root to the tips. felsenstein!() should usually be called first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[123]||(s[123]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/felsenstein.jl#L78-L86",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",q,[i("summary",null,[s[125]||(s[125]=i("a",{id:"MolecularEvolution.felsenstein_roundtrip!-Tuple{FelNode, Any}",href:"#MolecularEvolution.felsenstein_roundtrip!-Tuple{FelNode, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.felsenstein_roundtrip!")],-1)),s[126]||(s[126]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[128]||(s[128]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">felsenstein_roundtrip!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models; partition_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message), temp_message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> copy_message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message[partition_list]))</span></span></code></pre></div><p>Should usually be called on the root of the tree. First propagates Felsenstein pass up from the tips to the root, then propagates Felsenstein pass down from the root to the tips, with the direction of time reversed (i.e. forward! = backward!). <strong>This is useful when searching for the optimal root</strong> (see <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.root_optim!-Tuple{FelNode, Any}"><code>root_optim!</code></a>). models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[127]||(s[127]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/felsenstein.jl#L168-L177",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",U,[i("summary",null,[s[129]||(s[129]=i("a",{id:"MolecularEvolution.forward!-Tuple{DiscretePartition, DiscretePartition, MolecularEvolution.PMatrixModel, FelNode}",href:"#MolecularEvolution.forward!-Tuple{DiscretePartition, DiscretePartition, MolecularEvolution.PMatrixModel, FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.forward!")],-1)),s[130]||(s[130]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[132]||(s[132]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">forward!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dest</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BranchModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Propagate the source partition forwards along the branch to the destination partition, under the model. Note: You should overload this for your own BranchModel types.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[131]||(s[131]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/discrete_models/pmatrix_models/pmatrix_models.jl#L22-L27",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",W,[i("summary",null,[s[133]||(s[133]=i("a",{id:"MolecularEvolution.gappy_Q_from_symmetric_rate_matrix-Tuple{Any, Any, Any}",href:"#MolecularEvolution.gappy_Q_from_symmetric_rate_matrix-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.gappy_Q_from_symmetric_rate_matrix")],-1)),s[134]||(s[134]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[136]||(s[136]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gappy_Q_from_symmetric_rate_matrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sym_mat, gap_rate, eq_freqs)</span></span></code></pre></div><p>Takes a symmetric rate matrix and gap rate (governing mutations to and from gaps) and returns a gappy rate matrix. The equilibrium frequencies are multiplied on column-wise.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[135]||(s[135]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/discrete_models/utils/matrix_helpers.jl#L101-L106",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Q,[i("summary",null,[s[137]||(s[137]=i("a",{id:"MolecularEvolution.get_highlighter_legend-Tuple{Any}",href:"#MolecularEvolution.get_highlighter_legend-Tuple{Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.get_highlighter_legend")],-1)),s[138]||(s[138]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[140]||(s[140]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_highlighter_legend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(legend_colors)</span></span></code></pre></div><p>Returns a Compose object given an input dictionary or pairs mapping characters to colors.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[139]||(s[139]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/tree_compose.jl#L807-L811",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",K,[i("summary",null,[s[141]||(s[141]=i("a",{id:"MolecularEvolution.get_max_depth-Tuple{Any, Real}",href:"#MolecularEvolution.get_max_depth-Tuple{Any, Real}"},[i("span",{class:"jlbinding"},"MolecularEvolution.get_max_depth")],-1)),s[142]||(s[142]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[144]||(s[144]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_max_depth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node,depth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the maximum depth of all children starting from the indicated node.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[143]||(s[143]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/tree_compose.jl#L791-L795",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Y,[i("summary",null,[s[145]||(s[145]=i("a",{id:"MolecularEvolution.get_phylo_tree-Tuple{FelNode}",href:"#MolecularEvolution.get_phylo_tree-Tuple{FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.get_phylo_tree")],-1)),s[146]||(s[146]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[148]||(s[148]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_phylo_tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(molev_root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; data_function </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Tuple{String,Float64}[]))</span></span></code></pre></div><p>Converts a FelNode tree to a Phylo tree. The <code>data_function</code> should return a list of tuples of the form (key, value) to be added to the Phylo tree <code>data</code> Dictionary. Any key/value pairs on the FelNode <code>node_data</code> Dict will also be added to the Phylo tree.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[147]||(s[147]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/phylo_glue.jl#L45-L50",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",H,[i("summary",null,[s[149]||(s[149]=i("a",{id:"MolecularEvolution.golden_section_maximize-Tuple{Any, Real, Real, Any, Real}",href:"#MolecularEvolution.golden_section_maximize-Tuple{Any, Real, Real, Any, Real}"},[i("span",{class:"jlbinding"},"MolecularEvolution.golden_section_maximize")],-1)),s[150]||(s[150]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[152]||(s[152]=n(`<p>Golden section search.</p><p>Given a function f with a single local minimum in the interval [a,b], gss returns a subset interval [c,d] that contains the minimum with d-c &lt;= tol.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f (generic </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> with </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> method)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> golden_section_maximize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, identity, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e-10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0000000000051843</span></span></code></pre></div><p>From: <a href="https://en.wikipedia.org/wiki/Golden-section_search" target="_blank" rel="noreferrer">https://en.wikipedia.org/wiki/Golden-section_search</a></p>`,5)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[151]||(s[151]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/simple_optim.jl#L22-L40",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",$,[i("summary",null,[s[153]||(s[153]=i("a",{id:"MolecularEvolution.highlight_seq_draw-Tuple{Any, Any, AbstractString, Any, Any, Any}",href:"#MolecularEvolution.highlight_seq_draw-Tuple{Any, Any, AbstractString, Any, Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.highlight_seq_draw")],-1)),s[154]||(s[154]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[156]||(s[156]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">highlight_seq_draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y, str</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, region, basecolor, hicolor; fontsize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pt, posx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hcenter, posy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vcenter)</span></span></code></pre></div><p>Draw a sequence, highlighting the sites given in <code>region</code>. This can be used along with <code>compose_dict</code> for drawing sequences at nodes in a tree (see <code>tree_draw</code>). Returns a Compose container.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[155]||(s[155]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/tree_compose.jl#L641-L647",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",J,[i("summary",null,[s[157]||(s[157]=i("a",{id:"MolecularEvolution.highlighter_tree_draw-NTuple{4, Any}",href:"#MolecularEvolution.highlighter_tree_draw-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.highlighter_tree_draw")],-1)),s[158]||(s[158]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[160]||(s[160]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">highlighter_tree_draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree, ali_seqs, seqnames, master;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    highlighter_start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, highlighter_width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    coord_width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> highlighter_start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> highlighter_width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    scale_length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, major_breaks </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, minor_breaks </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    tree_args </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NamedTuple[], legend_padding </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm, legend_colors </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NUC_colors)</span></span></code></pre></div><p>Draws a combined tree and highlighter plot. The vector of seqnames must match the node names in <code>tree</code>.</p><p>kwargs:</p><ul><li><p>tree_args: kwargs to pass to <code>tree_draw()</code></p></li><li><p>legend_colors: Mapping of characters to highlighter colors (default NT_colors)</p></li><li><p>scale_length: Length of the scale bar</p></li><li><p>highlighter_start: Canvas start for the highlighter panel</p></li><li><p>highlighter_width: Canvas width for the highlighter panel</p></li><li><p>coord_width: Total width of the canvas</p></li><li><p>major_breaks: Numbered breaks for sequence axis</p></li><li><p>minor_breaks: Ticks for sequence axis</p></li></ul>`,4)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[159]||(s[159]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/tree_compose.jl#L888-L907",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",X,[i("summary",null,[s[161]||(s[161]=i("a",{id:"MolecularEvolution.internal_message_init!-Tuple{FelNode, Partition}",href:"#MolecularEvolution.internal_message_init!-Tuple{FelNode, Partition}"},[i("span",{class:"jlbinding"},"MolecularEvolution.internal_message_init!")],-1)),s[162]||(s[162]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[164]||(s[164]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">internal_message_init!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, partition</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Initializes the message template </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> each node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> the tree, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> an array of the partition.</span></span></code></pre></div>`,1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[163]||(s[163]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/FelNode.jl#L70-L74",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Z,[i("summary",null,[s[165]||(s[165]=i("a",{id:"MolecularEvolution.internal_message_init!-Tuple{FelNode, Vector{<:Partition}}",href:"#MolecularEvolution.internal_message_init!-Tuple{FelNode, Vector{<:Partition}}"},[i("span",{class:"jlbinding"},"MolecularEvolution.internal_message_init!")],-1)),s[166]||(s[166]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[168]||(s[168]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">internal_message_init!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, empty_message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{&lt;:Partition}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Initializes the message template </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> each node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> the tree, allocating space </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> each partition.</span></span></code></pre></div>`,1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[167]||(s[167]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/FelNode.jl#L55-L59",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ss,[i("summary",null,[s[169]||(s[169]=i("a",{id:"MolecularEvolution.internal_nodes-Tuple{Any}",href:"#MolecularEvolution.internal_nodes-Tuple{Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.internal_nodes")],-1)),s[170]||(s[170]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[172]||(s[172]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">internal_nodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree)</span></span></code></pre></div><p>Returns the internal nodes of the tree (including the root), as a vector.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[171]||(s[171]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/simple_interface.jl#L60-L64",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",is,[i("summary",null,[s[173]||(s[173]=i("a",{id:"MolecularEvolution.istreeconsistent-Tuple{T} where T<:AbstractTreeNode",href:"#MolecularEvolution.istreeconsistent-Tuple{T} where T<:AbstractTreeNode"},[i("span",{class:"jlbinding"},"MolecularEvolution.istreeconsistent")],-1)),s[174]||(s[174]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[176]||(s[176]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">istreeconsistent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root)</span></span></code></pre></div><p>Checks whether the <code>:parent</code> field is set to be consistent with the <code>:child</code> field for all nodes in the subtree.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[175]||(s[175]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/AbstractTreeNode.jl#L61-L65",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",es,[i("summary",null,[s[177]||(s[177]=i("a",{id:"MolecularEvolution.ladder_tree_sim-Tuple{Any}",href:"#MolecularEvolution.ladder_tree_sim-Tuple{Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.ladder_tree_sim")],-1)),s[178]||(s[178]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[180]||(s[180]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ladder_tree_sim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ntaxa)</span></span></code></pre></div><p>Simulates a ladder-like tree, using constant population size but heterochronous sampling, under a coalescent model.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[179]||(s[179]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/sim_tree.jl#L154-L158",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ls,[i("summary",null,[s[181]||(s[181]=i("a",{id:"MolecularEvolution.lazyprep!-Tuple{FelNode, Vector{<:Partition}}",href:"#MolecularEvolution.lazyprep!-Tuple{FelNode, Vector{<:Partition}}"},[i("span",{class:"jlbinding"},"MolecularEvolution.lazyprep!")],-1)),s[182]||(s[182]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[184]||(s[184]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lazyprep!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, initial_message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{&lt;:Partition}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; partition_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message), direction</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LazyDirection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LazyUp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Extra, intermediate step of tree preparations between initializing messages across the tree and calling message passing algorithms with <code>LazyPartition</code>.</p><ol><li><p>Perform a <code>lazysort!</code> on tree to obtain the optimal tree for a lazy <code>felsenstein!</code> prop, or a <code>sample_down!</code>.</p></li><li><p>Fix <code>tree.parent_message</code> to an initial message.</p></li><li><p>Preallocate sufficiently many inner partitions needed for a <code>felsenstein!</code> prop, or a <code>sample_down!</code>.</p></li><li><p>Specialized preparations based on the direction of the operations (<code>forward!</code>, <code>backward!</code>). <code>LazyDown</code> or <code>LazyUp</code>.</p></li></ol><p>See also <code>LazyDown</code>, <code>LazyUp</code>.</p>',4)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[183]||(s[183]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/lazy_models/lazy_partition.jl#L200-L210",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ts,[i("summary",null,[s[185]||(s[185]=i("a",{id:"MolecularEvolution.lazysort!-Tuple{FelNode}",href:"#MolecularEvolution.lazysort!-Tuple{FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.lazysort!")],-1)),s[186]||(s[186]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[188]||(s[188]=n('<ul><li><p>Should be run on a tree containing LazyPartitions before running <code>felsenstein!</code>. Sorts for a minimal count of active partitions during a felsenstein!</p></li><li><p>Returns the minimum length of memoryblocks (-1) required for a <code>felsenstein!</code> prop. We need a temporary memoryblock during <code>backward!</code>, hence the &#39;-1&#39;.</p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>Since felsenstein! uses a stack, we want to avoid having long node.children[1].children[1]... chains</p></div>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[187]||(s[187]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/lazy_models/lazy_partition.jl#L152-L157",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",as,[i("summary",null,[s[189]||(s[189]=i("a",{id:"MolecularEvolution.leaf_distmat-Tuple{Any}",href:"#MolecularEvolution.leaf_distmat-Tuple{Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.leaf_distmat")],-1)),s[190]||(s[190]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[192]||(s[192]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">leaf_distmat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree)</span></span></code></pre></div><p>Returns a matrix of the distances between the leaf nodes where the index on the columns and rows are sorted by the leaf names.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[191]||(s[191]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/bayes/sampling.jl#L150-L154",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ns,[i("summary",null,[s[193]||(s[193]=i("a",{id:"MolecularEvolution.leaf_names-Tuple{FelNode}",href:"#MolecularEvolution.leaf_names-Tuple{FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.leaf_names")],-1)),s[194]||(s[194]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[196]||(s[196]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">leaf_names</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree)</span></span></code></pre></div><p>Returns the names of the leaves of the tree.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[195]||(s[195]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/simple_interface.jl#L24-L28",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",os,[i("summary",null,[s[197]||(s[197]=i("a",{id:"MolecularEvolution.leaf_samples-Tuple{FelNode}",href:"#MolecularEvolution.leaf_samples-Tuple{FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.leaf_samples")],-1)),s[198]||(s[198]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[200]||(s[200]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">leaf_samples</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree; partition_inds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Returns the result of <code>partition2obs</code> for each leaf of the tree. Can be used eg. after <code>sample_down!</code> is called. If using a eg. codon model, this will extract a string from the CodonPartition on each leaf. Acts upon the first partition by default, but this can be changed by setting <code>partition_inds</code>, which can also be a vector of indices, in which case the result will be a vector for each leaf.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[199]||(s[199]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/simple_interface.jl#L4-L11",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",rs,[i("summary",null,[s[201]||(s[201]=i("a",{id:"MolecularEvolution.leaves-Tuple{Any}",href:"#MolecularEvolution.leaves-Tuple{Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.leaves")],-1)),s[202]||(s[202]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[204]||(s[204]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">leaves</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree)</span></span></code></pre></div><p>Returns the leaves of the tree, as a vector.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[203]||(s[203]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/simple_interface.jl#L46-L50",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ps,[i("summary",null,[s[205]||(s[205]=i("a",{id:"MolecularEvolution.linear_scale-NTuple{5, Any}",href:"#MolecularEvolution.linear_scale-NTuple{5, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.linear_scale")],-1)),s[206]||(s[206]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[208]||(s[208]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">linear_scale</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val,in_min,in_max,out_min,out_max)</span></span></code></pre></div><p>Linearly maps val which lives in [in_min,in_max] to a value in [out_min,out_max]</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[207]||(s[207]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/misc.jl#L199-L203",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ds,[i("summary",null,[s[209]||(s[209]=i("a",{id:"MolecularEvolution.log_likelihood!-Tuple{FelNode, Any}",href:"#MolecularEvolution.log_likelihood!-Tuple{FelNode, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.log_likelihood!")],-1)),s[210]||(s[210]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[212]||(s[212]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log_likelihood!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models; partition_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>First re-computes the upward felsenstein pass, and then computes the log likelihood of this tree. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[211]||(s[211]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/lls.jl#L45-L52",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",hs,[i("summary",null,[s[213]||(s[213]=i("a",{id:"MolecularEvolution.log_likelihood-Tuple{FelNode, BranchModel}",href:"#MolecularEvolution.log_likelihood-Tuple{FelNode, BranchModel}"},[i("span",{class:"jlbinding"},"MolecularEvolution.log_likelihood")],-1)),s[214]||(s[214]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[216]||(s[216]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log_likelihood</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models; partition_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Computed the log likelihood of this tree. Requires felsenstein!() to have been run. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[215]||(s[215]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/lls.jl#L27-L34",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",us,[i("summary",null,[s[217]||(s[217]=i("a",{id:"MolecularEvolution.longest_path-Tuple{FelNode}",href:"#MolecularEvolution.longest_path-Tuple{FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.longest_path")],-1)),s[218]||(s[218]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[220]||(s[220]=i("p",null,"Returns the longest path in a tree For convenience, this is returned as two lists of form: [leaf_node, parent_node, .... root] Where the leaf_node nodes are selected to be the furthest away",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[219]||(s[219]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/base_tree_utils.jl#L106-L111",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ks,[i("summary",null,[s[221]||(s[221]=i("a",{id:"MolecularEvolution.marginal_state_dict-Tuple{FelNode, Any}",href:"#MolecularEvolution.marginal_state_dict-Tuple{FelNode, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.marginal_state_dict")],-1)),s[222]||(s[222]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[224]||(s[224]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">marginal_state_dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model; partition_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message), node_message_dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict{FelNode,Vector{&lt;:Partition}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Takes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode-&gt;Array{&lt;:BranchModel}), and returns a dictionary mapping nodes to their marginal reconstructions (ie. P(state|all observations,model)). A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you&#39;re running this over and over.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[223]||(s[223]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/ancestors.jl#L111-L117",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",cs,[i("summary",null,[s[225]||(s[225]=i("a",{id:"MolecularEvolution.matrix_for_display-Tuple{Any, Any}",href:"#MolecularEvolution.matrix_for_display-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.matrix_for_display")],-1)),s[226]||(s[226]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[228]||(s[228]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">matrix_for_display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Q,labels)</span></span></code></pre></div><p>Takes a numerical matrix and a vector of labels, and returns a typically mixed type matrix with the numerical values and the labels. This is to easily visualize rate matrices in eg. the REPL.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[227]||(s[227]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/discrete_models/utils/matrix_helpers.jl#L196-L201",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",gs,[i("summary",null,[s[229]||(s[229]=i("a",{id:"MolecularEvolution.metropolis_sample-Tuple{AbstractUpdate, FelNode, Any, Any}",href:"#MolecularEvolution.metropolis_sample-Tuple{AbstractUpdate, FelNode, Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.metropolis_sample")],-1)),s[230]||(s[230]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[232]||(s[232]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">metropolis_sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    update!</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    initial_tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    models,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    num_of_samples;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    partition_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(initial_tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    burn_in </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sample_interval </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    collect_LLs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    collect_models </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    midpoint_rooting </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ladderize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Samples tree topologies from a posterior distribution using a custom <code>update!</code> function.</p><p><strong>Arguments</strong></p><ul><li><p><code>update!</code>: A callable that takes (tree::FelNode, models) and updates <code>tree</code> and <code>models</code>. One call to <code>update!</code> corresponds to one iteration of the Metropolis algorithm.</p></li><li><p><code>initial_tree</code>: An initial tree topology with the leaves populated with data, for the likelihood calculation.</p></li><li><p><code>models</code>: A list of branch models.</p></li><li><p><code>num_of_samples</code>: The number of tree samples drawn from the posterior.</p></li><li><p><code>partition_list</code>: (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over (but you probably want to sample with all partitions, the default option).</p></li><li><p><code>burn_in</code>: The number of samples discarded at the start of the Markov Chain.</p></li><li><p><code>sample_interval</code>: The distance between samples in the underlying Markov Chain (to reduce sample correlation).</p></li><li><p><code>collect_LLs</code>: Specifies if the function should return the log-likelihoods of the trees.</p></li><li><p><code>collect_models</code>: Specifies if the function should return the models.</p></li><li><p><code>midpoint_rooting</code>: Specifies whether the drawn samples should be midpoint rerooted (Important! Should only be used for time-reversible branch models starting in equilibrium).</p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The leaves of the initial tree should be populated with data and felsenstein! should be called on the initial tree before calling this function.</p></div><p><strong>Returns</strong></p><ul><li><p><code>samples</code>: The trees drawn from the posterior. Returns shallow tree copies, which needs to be repopulated before running felsenstein! etc.</p></li><li><p><code>sample_LLs</code>: The associated log-likelihoods of the tree (optional).</p></li><li><p><code>sample_models</code>: The models drawn from the posterior (optional). The models can be collapsed into it&#39;s parameters with <code>collapse_models</code>.</p></li></ul>`,7)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[231]||(s[231]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/bayes/sampling.jl#L1-L37",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Es,[i("summary",null,[s[233]||(s[233]=i("a",{id:"MolecularEvolution.metropolis_sample-Tuple{FelNode, Vector{<:BranchModel}, Any}",href:"#MolecularEvolution.metropolis_sample-Tuple{FelNode, Vector{<:BranchModel}, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.metropolis_sample")],-1)),s[234]||(s[234]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[236]||(s[236]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">metropolis_sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    initial_tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    models</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{&lt;:BranchModel}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    num_of_samples;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    bl_sampler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnivariateSampler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> BranchlengthSampler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Normal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Normal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    burn_in</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sample_interval</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    collect_LLs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    midpoint_rooting</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A convenience method. One step of the Metropolis algorithm is performed by calling <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.nni_update!-Tuple{Function, FelNode, Any}"><code>nni_update!</code></a> with <code>softmax_sampler</code> and <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.branchlength_update!-Tuple{MolecularEvolution.UnivariateModifier, FelNode, Any}"><code>branchlength_update!</code></a> with <code>bl_sampler</code>.</p><p><strong>Additional Arguments</strong></p><ul><li><code>bl_sampler</code>: Sampler used to drawn branchlengths from the posterior.</li></ul>`,4)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[235]||(s[235]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/bayes/sampling.jl#L108-L124",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ys,[i("summary",null,[s[237]||(s[237]=i("a",{id:"MolecularEvolution.metropolis_step-Tuple{Function, Any, Any}",href:"#MolecularEvolution.metropolis_step-Tuple{Function, Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.metropolis_step")],-1)),s[238]||(s[238]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[240]||(s[240]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">metropolis_step</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(LL</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, modifier, curr_value)</span></span></code></pre></div><p>Does a standard metropolis step in an MCMC, i.e. proposes a candidate symmetrically and returns the next state in the chain, decided by the candidate being rejected or not.</p><p><strong>Interface</strong></p><p>You need a <code>MySampler &lt;: Any</code> to implement</p><ul><li><p><code>proposal(modifier::MySampler, curr_value)</code></p></li><li><p><code>log_prior(modifier::MySampler, x)</code></p></li><li><p><code>apply_decision(modifier::MySampler, accept::Bool)</code></p></li></ul><p><code>LL</code> is by default called on <code>curr_value</code> and the returned value of <code>proposal</code>. Although, it is possible to transform the current value before proposing a new value, and then take the inverse transform to match the argument <code>LL</code> expects.</p><p><strong>Extended interface</strong></p><p>To make proposals in a transformed space, you overload</p><ul><li><p><code>tr(modifier::MySampler, x)</code></p></li><li><p><code>invtr(modifier::MySampler, x)</code></p></li></ul><p>which are identity transformations by default.</p>',10)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[239]||(s[239]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/simple_sample.jl#L27-L46",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",bs,[i("summary",null,[s[241]||(s[241]=i("a",{id:"MolecularEvolution.midpoint-Tuple{FelNode}",href:"#MolecularEvolution.midpoint-Tuple{FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.midpoint")],-1)),s[242]||(s[242]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[244]||(s[244]=i("p",null,"Returns a midpoint as a node and a distance above it where the midpoint is",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[243]||(s[243]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/base_tree_utils.jl#L126",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ms,[i("summary",null,[s[245]||(s[245]=i("a",{id:"MolecularEvolution.mix-Union{Tuple{SWMPartition{PType}}, Tuple{PType}} where PType<:DiscretePartition",href:"#MolecularEvolution.mix-Union{Tuple{SWMPartition{PType}}, Tuple{PType}} where PType<:DiscretePartition"},[i("span",{class:"jlbinding"},"MolecularEvolution.mix")],-1)),s[246]||(s[246]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[248]||(s[248]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(swm_part</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SWMPartition{PType}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {PType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MultiSitePartition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>mix</code> collapses a Site-Wise Mixture partition to a single component partition, weighted by the site-wise likelihoods for each component, and the init weights. Specifically, it takes a <code>SWMPartition{Ptype}</code> and returns a <code>PType</code>. You&#39;ll need to have this implemented for certain helper functionality if you&#39;re playing with new kinds of SWMPartitions that aren&#39;t mixtures of <code>DiscretePartitions</code>.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[247]||(s[247]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/compound_models/swm.jl#L169-L175",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",_s,[i("summary",null,[s[249]||(s[249]=i("a",{id:"MolecularEvolution.name2node_dict-Tuple{AbstractTreeNode}",href:"#MolecularEvolution.name2node_dict-Tuple{AbstractTreeNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.name2node_dict")],-1)),s[250]||(s[250]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[252]||(s[252]=i("p",null,"name2node_dict(root)",-1)),s[253]||(s[253]=i("p",null,"Returns a dictionary of leaf nodes, indexed by node.name. Can be used to associate sequences with leaf nodes.",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[251]||(s[251]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/AbstractTreeNode.jl#L540-L544",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",fs,[i("summary",null,[s[254]||(s[254]=i("a",{id:"MolecularEvolution.newick-Tuple{AbstractTreeNode}",href:"#MolecularEvolution.newick-Tuple{AbstractTreeNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.newick")],-1)),s[255]||(s[255]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[257]||(s[257]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">newick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root)</span></span></code></pre></div><p>Returns a newick string representation of the tree.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[256]||(s[256]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/AbstractTreeNode.jl#L626-L630",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",vs,[i("summary",null,[s[258]||(s[258]=i("a",{id:"MolecularEvolution.nni_optim!-Tuple",href:"#MolecularEvolution.nni_optim!-Tuple"},[i("span",{class:"jlbinding"},"MolecularEvolution.nni_optim!")],-1)),s[259]||(s[259]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[261]||(s[261]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nni_optim!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Considers local branch swaps for all branches recursively, maintaining the integrity of the messages. Requires felsenstein!() to have been run first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>partition_list=nothing</code>: (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over (but you probably want to optimize tree topology with all models, the default option).</p></li><li><p><code>selection_rule = x -&gt; argmax(x)</code>: a function that takes the current and proposed log likelihoods and selects a nni configuration. Note that the current log likelihood is stored at x[1].</p></li><li><p><code>sort_tree=false</code>: determines if a <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.lazysort!-Tuple{FelNode}"><code>lazysort!</code></a> will be performed, which can reduce the amount of temporary messages that has to be initialized.</p></li><li><p><code>traversal=Iterators.reverse</code>: a function that determines the traversal, permutes an iterable.</p></li><li><p><code>shuffle=false</code>: do a randomly shuffled traversal, overrides <code>traversal</code>.</p></li></ul>',4)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[260]||(s[260]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/nni_optim.jl#L323-L337",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Fs,[i("summary",null,[s[262]||(s[262]=i("a",{id:"MolecularEvolution.nni_update!-Tuple{Function, FelNode, Any}",href:"#MolecularEvolution.nni_update!-Tuple{Function, FelNode, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.nni_update!")],-1)),s[263]||(s[263]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[265]||(s[265]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nni_update!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(selection_rule</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A more verbose version of <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/optimization#MolecularEvolution.nni_optim!"><code>nni_optim!</code></a>.</p><p><strong>Keyword Arguments</strong></p><p>See <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/optimization#MolecularEvolution.nni_optim!"><code>nni_optim!</code></a>.</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p><code>selection_rule</code> is a positional argument here, and not a keyword argument.</p></div>',5)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[264]||(s[264]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/nni_optim.jl#L287-L296",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Ts,[i("summary",null,[s[266]||(s[266]=i("a",{id:"MolecularEvolution.node_distances-Tuple{AbstractTreeNode}",href:"#MolecularEvolution.node_distances-Tuple{AbstractTreeNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.node_distances")],-1)),s[267]||(s[267]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[269]||(s[269]=i("p",null,"Compute the distance to all other nodes from a given node",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[268]||(s[268]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/base_tree_utils.jl#L58",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Ms,[i("summary",null,[s[270]||(s[270]=i("a",{id:"MolecularEvolution.node_names-Tuple{FelNode}",href:"#MolecularEvolution.node_names-Tuple{FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.node_names")],-1)),s[271]||(s[271]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[273]||(s[273]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">node_names</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree)</span></span></code></pre></div><p>Returns the names of the nodes of the tree.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[272]||(s[272]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/simple_interface.jl#L31-L35",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Cs,[i("summary",null,[s[274]||(s[274]=i("a",{id:"MolecularEvolution.node_samples-Tuple{FelNode}",href:"#MolecularEvolution.node_samples-Tuple{FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.node_samples")],-1)),s[275]||(s[275]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[277]||(s[277]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">node_samples</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree; partition_inds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Returns the result of <code>partition2obs</code> for each node of the tree (including internal nodes, and the root). Can be used eg. after <code>sample_down!</code> is called. If using a eg. codon model, this will extract a string from the CodonPartition on each node. Acts upon the first partition by default, but this can be changed by setting <code>partition_inds</code>, which can also be a vector of indices, in which case the result will be a vector for each node.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[276]||(s[276]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/simple_interface.jl#L14-L21",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",js,[i("summary",null,[s[278]||(s[278]=i("a",{id:"MolecularEvolution.nodes-Tuple{Any}",href:"#MolecularEvolution.nodes-Tuple{Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.nodes")],-1)),s[279]||(s[279]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[281]||(s[281]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree)</span></span></code></pre></div><p>Returns the nodes of the tree (including internal nodes and the root), as a vector.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[280]||(s[280]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/simple_interface.jl#L53-L57",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",As,[i("summary",null,[s[282]||(s[282]=i("a",{id:"MolecularEvolution.nonreversibleQ-Tuple{Any}",href:"#MolecularEvolution.nonreversibleQ-Tuple{Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.nonreversibleQ")],-1)),s[283]||(s[283]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[285]||(s[285]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nonreversibleQ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(param_vec)</span></span></code></pre></div><p>Takes a vector of parameters and returns a nonreversible rate matrix.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[284]||(s[284]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/discrete_models/utils/matrix_helpers.jl#L151-L155",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",xs,[i("summary",null,[s[286]||(s[286]=i("a",{id:"MolecularEvolution.parent_list-Tuple{FelNode}",href:"#MolecularEvolution.parent_list-Tuple{FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.parent_list")],-1)),s[287]||(s[287]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[289]||(s[289]=i("p",null,"Provides a list of parent nodes nodes from this node up to the root node",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[288]||(s[288]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/base_tree_utils.jl#L73",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Ds,[i("summary",null,[s[290]||(s[290]=i("a",{id:"MolecularEvolution.partition2obs-Tuple{DiscretePartition, String}",href:"#MolecularEvolution.partition2obs-Tuple{DiscretePartition, String}"},[i("span",{class:"jlbinding"},"MolecularEvolution.partition2obs")],-1)),s[291]||(s[291]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[293]||(s[293]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">partition2obs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(part</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Extracts the most likely state from a Partition, transforming it into a convenient type. For example, a NucleotidePartition will be transformed into a nucleotide sequence of type String. Note: You should overload this for your own Partititon types.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[292]||(s[292]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/discrete_models/utils/seq_to_vec.jl#L70-L76",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ws,[i("summary",null,[s[294]||(s[294]=i("a",{id:"MolecularEvolution.plot_multiple_trees-Tuple{Any, Any}",href:"#MolecularEvolution.plot_multiple_trees-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.plot_multiple_trees")],-1)),s[295]||(s[295]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[297]||(s[297]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">plot_multiple_trees</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(trees, inf_tree; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Plots multiple phylogenetic trees against a reference tree, <code>inf_tree</code>. For each <strong>tree</strong> in <code>trees</code>, a linear Weighted Least Squares (WLS) problem (parameterized by the <code>weight_fn</code> keyword) is solved for the x-positions of the matching nodes between <code>inf_tree</code> and <strong>tree</strong>.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>node_size=4</code>: the size of the nodes in the plot.</p></li><li><p><code>line_width=0.5</code>: the width of the branches from <code>trees</code>.</p></li><li><p><code>font_size=10</code>: the font size for the leaf labels.</p></li><li><p><code>margin=1.5</code>: the margin between a leaf node and its label.</p></li><li><p><code>line_alpha=0.05</code>: the transparency level of the branches from <code>trees</code>.</p></li><li><p><code>y_jitter=0.0</code>: the standard deviation of the noise in the y-coordinate.</p></li><li><p><code>weight_fn=n::FelNode -&gt; ifelse(isroot(n), 1.0, 0.0))</code>: a function that assigns a weight to a node for the WLS problem.</p></li><li><p><code>opt_scale=true</code>: whether to include a scaling parameter for the WLS problem.</p></li></ul>',4)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[296]||(s[296]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/multiple_trees.jl#L74-L89",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Ss,[i("summary",null,[s[298]||(s[298]=i("a",{id:"MolecularEvolution.populate_tree!-Tuple{FelNode, Partition, Any, Any}",href:"#MolecularEvolution.populate_tree!-Tuple{FelNode, Partition, Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.populate_tree!")],-1)),s[299]||(s[299]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[301]||(s[301]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">populate_tree!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, starting_message, names, data; init_all_messages </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tolerate_missing </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, leaf_name_transform </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x)</span></span></code></pre></div><p>Takes a tree, and a <code>starting_message</code> (which will serve as the memory template for populating messages all over the tree). <code>starting_message</code> can be a message (ie. a vector of Partitions), but will also work with a single Partition (although the tree) will still be populated with a length-1 vector of Partitions. Further, as long as <code>obs2partition</code> is implemented for your Partition type, the leaf nodes will be populated with the data from <code>data</code>, matching the names on each leaf. When a leaf on the tree has a name that doesn&#39;t match anything in <code>names</code>, then if</p><ul><li><p><code>tolerate_missing = 0</code>, an error will be thrown</p></li><li><p><code>tolerate_missing = 1</code>, a warning will be thrown, and the message will be set to the uninformative message (requires identity!(::Partition) to be defined)</p></li><li><p><code>tolerate_missing = 2</code>, the message will be set to the uninformative message, without warnings (requires identity!(::Partition) to be defined)</p></li></ul><p>A renaming function that can eg. strip tags from the tree when matching leaf names with <code>names</code> can be passed to <code>leaf_name_transform</code></p>',4)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[300]||(s[300]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/misc.jl#L110-L122",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Bs,[i("summary",null,[s[302]||(s[302]=i("a",{id:"MolecularEvolution.promote_internal-Tuple{FelNode}",href:"#MolecularEvolution.promote_internal-Tuple{FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.promote_internal")],-1)),s[303]||(s[303]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[305]||(s[305]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">promote_internal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a new tree similar to the given tree, but with &#39;dummy&#39; leaf nodes (w/ zero branchlength) representing each internal node (for drawing / evenly spacing labels internal nodes).</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[304]||(s[304]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/tree_compose.jl#L615-L620",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Ps,[i("summary",null,[s[306]||(s[306]=i("a",{id:"MolecularEvolution.quadratic_CI-Tuple{Function, Vector, Int64}",href:"#MolecularEvolution.quadratic_CI-Tuple{Function, Vector, Int64}"},[i("span",{class:"jlbinding"},"MolecularEvolution.quadratic_CI")],-1)),s[307]||(s[307]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[309]||(s[309]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">quadratic_CI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,opt_params</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, param_ind</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; rate_conf_level </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.99</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, nudge_amount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Takes a NEGATIVE log likelihood function (compatible with Optim.jl), a vector of maximizing parameters, an a parameter index. Returns the quadratic confidence interval.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[308]||(s[308]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/simple_optim.jl#L357-L362",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Ns,[i("summary",null,[s[310]||(s[310]=i("a",{id:"MolecularEvolution.quadratic_CI-Tuple{Vector, Vector}",href:"#MolecularEvolution.quadratic_CI-Tuple{Vector, Vector}"},[i("span",{class:"jlbinding"},"MolecularEvolution.quadratic_CI")],-1)),s[311]||(s[311]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[313]||(s[313]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">quadratic_CI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xvec,yvec; rate_conf_level </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.99</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Takes xvec, a vector of parameter values, and yvec, a vector of log likelihood evaluations (note: NOT the negative LLs you) might use with Optim.jl. Returns the confidence intervals computed by a quadratic approximation to the LL.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[312]||(s[312]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/simple_optim.jl#L333-L339",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Ls,[i("summary",null,[s[314]||(s[314]=i("a",{id:"MolecularEvolution.read_fasta-Tuple{String}",href:"#MolecularEvolution.read_fasta-Tuple{String}"},[i("span",{class:"jlbinding"},"MolecularEvolution.read_fasta")],-1)),s[315]||(s[315]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[317]||(s[317]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">read_fasta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filepath</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Reads in a fasta file and returns a tuple of (seqnames, seqs).</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[316]||(s[316]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/fasta_io.jl#L4-L8",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Vs,[i("summary",null,[s[318]||(s[318]=i("a",{id:"MolecularEvolution.read_newick_tree-Tuple{String}",href:"#MolecularEvolution.read_newick_tree-Tuple{String}"},[i("span",{class:"jlbinding"},"MolecularEvolution.read_newick_tree")],-1)),s[319]||(s[319]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[321]||(s[321]=i("p",null,"read_newick_tree(treefile)",-1)),s[322]||(s[322]=i("p",null,"Reads in a tree from a file, of type FelNode",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[320]||(s[320]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/misc.jl#L256-L260",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Is,[i("summary",null,[s[323]||(s[323]=i("a",{id:"MolecularEvolution.reversibleQ-Tuple{Any, Any}",href:"#MolecularEvolution.reversibleQ-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.reversibleQ")],-1)),s[324]||(s[324]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[326]||(s[326]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reversibleQ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(param_vec,eq_freqs)</span></span></code></pre></div><p>Takes a vector of parameters and equilibrium frequencies and returns a reversible rate matrix. The parameters are the upper triangle of the rate matrix, with the diagonal elements omitted, and the equilibrium frequencies are multiplied column-wise.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[325]||(s[325]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/discrete_models/utils/matrix_helpers.jl#L122-L128",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Rs,[i("summary",null,[s[327]||(s[327]=i("a",{id:"MolecularEvolution.root2tip_distances-Tuple{AbstractTreeNode}",href:"#MolecularEvolution.root2tip_distances-Tuple{AbstractTreeNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.root2tip_distances")],-1)),s[328]||(s[328]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[330]||(s[330]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">root2tips</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractTreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Returns a vector of root-to-tip distances, and a node-to-index dictionary. Be aware that this dictionary will break when any of the node content (ie. anything on the tree) changes.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[329]||(s[329]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/AbstractTreeNode.jl#L773-L778",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",zs,[i("summary",null,[s[331]||(s[331]=i("a",{id:"MolecularEvolution.root_optim!-Tuple{FelNode, Any}",href:"#MolecularEvolution.root_optim!-Tuple{FelNode, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.root_optim!")],-1)),s[332]||(s[332]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[334]||(s[334]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">root_optim!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Optimizes the root position and root state of a tree. Returns the new, optimal root node. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>partition_list=1:length(tree.message)</code>: (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over (but you probably want to optimize root position and root state with all models, the default option).</p></li><li><p><code>root_LL!=default_root_LL_wrapper(tree.parent_message[partition_list])</code>: a function that takes a message and returns a (optimal) parent message and LL (log likelihood). The default option uses the constant <code>tree.parent_message[partition_list]</code> as parent message for all root-candidates.</p></li><li><p><code>K=10</code>: the number of equidistant root-candidate points along a branch. (only to be used in the frequentist framework!?)</p></li></ul>',4)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[333]||(s[333]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/root_optim.jl#L106-L117",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Gs,[i("summary",null,[s[335]||(s[335]=i("a",{id:"MolecularEvolution.root_update!-Tuple{RootUpdate, FelNode, Any}",href:"#MolecularEvolution.root_update!-Tuple{RootUpdate, FelNode, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.root_update!")],-1)),s[336]||(s[336]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[338]||(s[338]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">root_update!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root_update</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RootUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models; partition_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message))</span></span></code></pre></div><p>A more general version of <a href="/MurrellGroup.github.io/MolecularEvolution.jl/dev/api#MolecularEvolution.root_optim!-Tuple{FelNode, Any}"><code>root_optim!</code></a>. Here <code>root_update</code> can be either an optimization or a sampling (or more generally, a RootUpdate).</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[337]||(s[337]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/root_optim.jl#L86-L90",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Os,[i("summary",null,[s[339]||(s[339]=i("a",{id:"MolecularEvolution.sample_down!-Tuple{FelNode, Any, Any}",href:"#MolecularEvolution.sample_down!-Tuple{FelNode, Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.sample_down!")],-1)),s[340]||(s[340]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[342]||(s[342]=i("p",null,"sample_down!(root::FelNode,models,partition_list)",-1)),s[343]||(s[343]=i("p",null,"Generates samples under the model. The root.parent_message is taken as the starting distribution, and node.message contains the sampled messages. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have >1 Partition, or a function that takes a node, and returns a Vector{<:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[341]||(s[341]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/generative.jl#L14-L21",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",qs,[i("summary",null,[s[344]||(s[344]=i("a",{id:"MolecularEvolution.sample_from_message!-Tuple{Vector{<:Partition}}",href:"#MolecularEvolution.sample_from_message!-Tuple{Vector{<:Partition}}"},[i("span",{class:"jlbinding"},"MolecularEvolution.sample_from_message!")],-1)),s[345]||(s[345]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[347]||(s[347]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_from_message!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{&lt;:Partition}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>#Replaces an uncertain message with a sample from the distribution represented by each partition.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[346]||(s[346]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/generative.jl#L5-L9",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Us,[i("summary",null,[s[348]||(s[348]=i("a",{id:"MolecularEvolution.savefig_tweakSVG-Tuple{Any, Context}",href:"#MolecularEvolution.savefig_tweakSVG-Tuple{Any, Context}"},[i("span",{class:"jlbinding"},"MolecularEvolution.savefig_tweakSVG")],-1)),s[349]||(s[349]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[351]||(s[351]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">savefig_tweakSVG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fname, plot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm, height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm, linecap_round </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, white_background </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Saves a figure created using the <code>Compose</code> approach, but tweaks the SVG after export.</p><p>eg. <code>savefig_tweakSVG(&quot;export.svg&quot;,pl)</code></p>',3)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[350]||(s[350]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/tree_compose.jl#L1012-L1018",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Ws,[i("summary",null,[s[352]||(s[352]=i("a",{id:"MolecularEvolution.savefig_tweakSVG-Tuple{Any, Plots.Plot}",href:"#MolecularEvolution.savefig_tweakSVG-Tuple{Any, Plots.Plot}"},[i("span",{class:"jlbinding"},"MolecularEvolution.savefig_tweakSVG")],-1)),s[353]||(s[353]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[355]||(s[355]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">savefig_tweakSVG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fname, plot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Plots.Plot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; hack_bounding_box </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, new_viewbox </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, linecap_round </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Note: Might only work if you&#39;re using the GR backend!! Saves a figure created using the <code>Phylo</code> <code>Plots</code> recipe, but tweaks the SVG after export. <code>new_viewbox</code> needs to be an array of 4 numbers, typically starting at <code>[0 0 plot_width*4 plot_height*4]</code> but this lets you add shifts, in case the plot is getting cut off.</p><p>eg. <code>savefig_tweakSVG(&quot;export.svg&quot;,pl, new_viewbox = [-100, -100, 3000, 4500])</code></p>',3)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[354]||(s[354]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/phylo_glue.jl#L84-L93",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Qs,[i("summary",null,[s[356]||(s[356]=i("a",{id:"MolecularEvolution.shortest_path_between_nodes-Tuple{FelNode, FelNode}",href:"#MolecularEvolution.shortest_path_between_nodes-Tuple{FelNode, FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.shortest_path_between_nodes")],-1)),s[357]||(s[357]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[359]||(s[359]=i("p",null,"Shortest path between nodes, returned as two lists, each starting with one of the two nodes, and ending with the common ancestor",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[358]||(s[358]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/base_tree_utils.jl#L84-L87",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Ks,[i("summary",null,[s[360]||(s[360]=i("a",{id:"MolecularEvolution.sibling_inds-Tuple{AbstractTreeNode}",href:"#MolecularEvolution.sibling_inds-Tuple{AbstractTreeNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.sibling_inds")],-1)),s[361]||(s[361]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[363]||(s[363]=i("p",null,"sibling_inds(node)",-1)),s[364]||(s[364]=i("p",null,"Returns logical indices of the siblings in the parent's child's vector.",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[362]||(s[362]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/AbstractTreeNode.jl#L526-L530",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Ys,[i("summary",null,[s[365]||(s[365]=i("a",{id:"MolecularEvolution.siblings-Tuple{AbstractTreeNode}",href:"#MolecularEvolution.siblings-Tuple{AbstractTreeNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.siblings")],-1)),s[366]||(s[366]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[368]||(s[368]=i("p",null,"siblings(node)",-1)),s[369]||(s[369]=i("p",null,"Returns a vector of siblings of node.",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[367]||(s[367]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/AbstractTreeNode.jl#L512-L516",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Hs,[i("summary",null,[s[370]||(s[370]=i("a",{id:"MolecularEvolution.sim_tree-Tuple{Int64, Any, Any}",href:"#MolecularEvolution.sim_tree-Tuple{Int64, Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.sim_tree")],-1)),s[371]||(s[371]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[373]||(s[373]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sim_tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(add_limit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,Ne_func,sample_rate_func; nstart </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, time </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mutation_rate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float64)</span></span></code></pre></div><p>Simulates a tree of type FelNode{T}. Allows an effective population size function (Ne_func), as well as a sample rate function (sample_rate_func), which can also just be constants.</p><p>Ne_func(t) = (sin(t/10)+1)*100.0 + 10.0 root = sim_tree(600,Ne_func,1.0) simple_tree_draw(ladderize(root))</p>',3)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[372]||(s[372]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/sim_tree.jl#L94-L103",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",$s,[i("summary",null,[s[374]||(s[374]=i("a",{id:"MolecularEvolution.sim_tree-Tuple{}",href:"#MolecularEvolution.sim_tree-Tuple{}"},[i("span",{class:"jlbinding"},"MolecularEvolution.sim_tree")],-1)),s[375]||(s[375]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[377]||(s[377]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sim_tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(;n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Simulates tree with constant population size.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[376]||(s[376]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/sim_tree.jl#L132-L137",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Js,[i("summary",null,[s[378]||(s[378]=i("a",{id:"MolecularEvolution.simple_radial_tree_plot-Tuple{FelNode}",href:"#MolecularEvolution.simple_radial_tree_plot-Tuple{FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.simple_radial_tree_plot")],-1)),s[379]||(s[379]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[381]||(s[381]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simple_radial_tree_plot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; canvas_width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm, line_color </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;black&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, line_width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mm)</span></span></code></pre></div><p>Draws a radial tree. No frills. No labels. Canvas height is automatically determined to avoid distorting the tree.</p><p>newt = better_newick_import(&quot;((A:1,B:1,C:1,D:1,E:1,F:1,G:1):1,(H:1,I:1):1);&quot;, FelNode{Float64}); simple_radial_tree_plot(newt,line_width = 0.5mm,root_angle = 7/10)</p>',3)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[380]||(s[380]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/tree_compose.jl#L423-L430",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Xs,[i("summary",null,[s[382]||(s[382]=i("a",{id:"MolecularEvolution.simple_tree_draw-Tuple{FelNode}",href:"#MolecularEvolution.simple_tree_draw-Tuple{FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.simple_tree_draw")],-1)),s[383]||(s[383]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[385]||(s[385]=n(`<p>img = simple_tree_draw(tree::FelNode; canvas_width = 15cm, canvas_height = 15cm, line_color = &quot;black&quot;, line_width = 0.1mm)</p><p>A line drawing of a tree with very few options.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">img </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> simple_tree_draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">img </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> SVG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;imgout.svg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">OR</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Cairo</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">img </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PDF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;imgout.pdf&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm)</span></span></code></pre></div>`,3)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[384]||(s[384]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/tree_compose.jl#L92-L104",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",Zs,[i("summary",null,[s[386]||(s[386]=i("a",{id:"MolecularEvolution.standard_tree_sim-Tuple{Any}",href:"#MolecularEvolution.standard_tree_sim-Tuple{Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.standard_tree_sim")],-1)),s[387]||(s[387]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[389]||(s[389]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">standard_tree_sim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ntaxa)</span></span></code></pre></div><p>Simulates a tree with logistic population growth, under a coalescent model.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[388]||(s[388]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/sim_tree.jl#L143-L147",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",si,[i("summary",null,[s[390]||(s[390]=i("a",{id:"MolecularEvolution.total_LL-Tuple{Partition}",href:"#MolecularEvolution.total_LL-Tuple{Partition}"},[i("span",{class:"jlbinding"},"MolecularEvolution.total_LL")],-1)),s[391]||(s[391]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[393]||(s[393]=i("p",null,"total_LL(p::Partition)",-1)),s[394]||(s[394]=i("p",null,"If called on the root, it returns the log likelihood associated with that partition. Can be overloaded for complex partitions without straightforward site log likelihoods.",-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[392]||(s[392]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/algorithms/lls.jl#L2-L7",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ii,[i("summary",null,[s[395]||(s[395]=i("a",{id:"MolecularEvolution.tree2distances-Tuple{AbstractTreeNode}",href:"#MolecularEvolution.tree2distances-Tuple{AbstractTreeNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.tree2distances")],-1)),s[396]||(s[396]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[398]||(s[398]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tree2distances</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractTreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Returns a distance matrix for all pairs of leaf nodes, and a node-to-index dictionary. Be aware that this dictionary will break when any of the node content (ie. anything on the tree) changes.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[397]||(s[397]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/AbstractTreeNode.jl#L736-L741",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ei,[i("summary",null,[s[399]||(s[399]=i("a",{id:"MolecularEvolution.tree2shared_branch_lengths-Tuple{AbstractTreeNode}",href:"#MolecularEvolution.tree2shared_branch_lengths-Tuple{AbstractTreeNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.tree2shared_branch_lengths")],-1)),s[400]||(s[400]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[402]||(s[402]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tree2distances</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractTreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Returns a distance matrix for all pairs of leaf nodes, and a node-to-index dictionary. Be aware that this dictionary will break when any of the node content (ie. anything on the tree) changes.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[401]||(s[401]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/core/nodes/AbstractTreeNode.jl#L791-L796",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",li,[i("summary",null,[s[403]||(s[403]=i("a",{id:"MolecularEvolution.tree_draw-Tuple{FelNode}",href:"#MolecularEvolution.tree_draw-Tuple{FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.tree_draw")],-1)),s[404]||(s[404]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[406]||(s[406]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tree_draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    canvas_width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm, canvas_height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    stretch_for_labels </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, draw_labels </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    line_width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mm, font_size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    min_dot_size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.00</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, max_dot_size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    line_opacity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dot_opacity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name_opacity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    horizontal </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dot_size_dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), dot_size_default </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dot_color_dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), dot_color_default </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;black&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    line_color_dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), line_color_default </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;black&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    label_color_dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), label_color_default </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;black&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nodelabel_dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),compose_dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span></code></pre></div><p>Draws a tree with a number of self-explanatory options. Dictionaries that map a node to a color/size are used to control per-node plotting options. <code>compose_dict</code> must be a <code>FelNode-&gt;function(x,y)</code> dictionary that returns a <code>compose()</code> struct.</p><p>Example using <code>compose_dict</code></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">str_tree </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;(((((tax24:0.09731668728575642,(tax22:0.08792233964843627,tax18:0.9210388482867483):0.3200367900275155):0.6948314526087965,(tax13:1.9977212308725611,(tax15:0.4290074347886068,(tax17:0.32928401808187824,(tax12:0.3860215462534818,tax16:0.2197134841232339):0.1399122681886174):0.05744611946245004):1.4686085778061146):0.20724159879522402):0.4539334554156126,tax28:0.4885576926440158):0.002162260013924424,tax26:0.9451873777301325):3.8695419798779387,((tax29:0.10062813251515536,tax27:0.27653633028085006):0.04262434258357507,(tax25:0.009345653929737636,((tax23:0.015832941547076644,(tax20:0.5550597590956172,((tax8:0.6649025646927402,tax9:0.358506423199849):0.1439516404012261,tax11:0.01995439013213013):1.155181296134081):0.17930021667907567):0.10906638146207207,((((((tax6:0.013708993438720255,tax5:0.061144001556547097):0.1395453591567641,tax3:0.4713722705245479):0.07432598428904214,tax1:0.5993347898257291):1.0588025698844894,(tax10:0.13109032492533992,(tax4:0.8517302241963356,(tax2:0.8481963081549965,tax7:0.23754095940676642):0.2394313086297733):0.43596704123297675):0.08774657269409454):0.9345533723114966,(tax14:0.7089558245245173,tax19:0.444897137240675):0.08657675809803095):0.01632062723968511,tax21:0.029535281963725537):0.49502691718938285):0.25829576024240986):0.7339777396780424):4.148878039524972):0.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">newt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> gettreefromnewick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str_tree, FelNode)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ladderize!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newt)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">compose_dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> getleaflist</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newt)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    #Replace the rand(4) with the frequencies you actually want.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    compose_dict[n] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x,y)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pie_chart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x,y,MolecularEvolution</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sum2one</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)),size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tree_draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newt,draw_labels </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,line_width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mm, compose_dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> compose_dict)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">img </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tree_draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">img </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> SVG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;imgout.svg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">OR</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Cairo</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">img </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PDF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;imgout.pdf&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cm)</span></span></code></pre></div>`,4)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[405]||(s[405]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/tree_compose.jl#L137-L177",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ti,[i("summary",null,[s[407]||(s[407]=i("a",{id:"MolecularEvolution.tree_polish!-Tuple{Any, Any}",href:"#MolecularEvolution.tree_polish!-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.tree_polish!")],-1)),s[408]||(s[408]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[410]||(s[410]=i("p",null,"tree_polish!(newt, models; tol = 10^-4, verbose = 1, topology = true)",-1)),s[411]||(s[411]=i("p",null,[t("Takes a tree and a model function, and optimizes branch lengths and, optionally, topology. Returns final LL. Set "),i("code",null,"verbose=0"),t(" to suppress output. Note: This is not intended for an exhaustive tree search (which requires different heuristics), but rather to polish a tree that is already relatively close to the optimum.")],-1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[409]||(s[409]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/misc.jl#L160-L165",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ai,[i("summary",null,[s[412]||(s[412]=i("a",{id:"MolecularEvolution.unc2probvec-Tuple{Any}",href:"#MolecularEvolution.unc2probvec-Tuple{Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.unc2probvec")],-1)),s[413]||(s[413]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[415]||(s[415]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">unc2probvec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v)</span></span></code></pre></div><p>Takes an array of N-1 unbounded values and returns an array of N values that sums to 1. Typically useful for optimizing over categorical probability distributions.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[414]||(s[414]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/models/discrete_models/utils/matrix_helpers.jl#L177-L181",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ni,[i("summary",null,[s[416]||(s[416]=i("a",{id:"MolecularEvolution.univariate_maximize-Tuple{Any, Real, Real, Any, BrentsMethodOpt, Real}",href:"#MolecularEvolution.univariate_maximize-Tuple{Any, Real, Real, Any, BrentsMethodOpt, Real}"},[i("span",{class:"jlbinding"},"MolecularEvolution.univariate_maximize")],-1)),s[417]||(s[417]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[419]||(s[419]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">univariate_maximize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, transform, optimizer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BrentsMethodOpt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; ε</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sqrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(eps))</span></span></code></pre></div><p>Maximizes <code>f(x)</code> using Brent&#39;s method. See <code>?brents_method_minimize</code>.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[418]||(s[418]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/simple_optim.jl#L198-L202",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",oi,[i("summary",null,[s[420]||(s[420]=i("a",{id:"MolecularEvolution.univariate_maximize-Tuple{Any, Real, Real, Any, GoldenSectionOpt, Real}",href:"#MolecularEvolution.univariate_maximize-Tuple{Any, Real, Real, Any, GoldenSectionOpt, Real}"},[i("span",{class:"jlbinding"},"MolecularEvolution.univariate_maximize")],-1)),s[421]||(s[421]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[423]||(s[423]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">univariate_maximize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, transform, optimizer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GoldenSectionOpt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Maximizes <code>f(x)</code> using a Golden Section Search. See <code>?golden_section_maximize</code>.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f (generic </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> with </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> method)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> univariate_maximize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, identity, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GoldenSectionOpt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e-10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0000000000051843</span></span></code></pre></div>`,4)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[422]||(s[422]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/simple_optim.jl#L77-L89",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ri,[i("summary",null,[s[424]||(s[424]=i("a",{id:"MolecularEvolution.univariate_sampler-Tuple{Any, BranchlengthSampler, Any}",href:"#MolecularEvolution.univariate_sampler-Tuple{Any, BranchlengthSampler, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.univariate_sampler")],-1)),s[425]||(s[425]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[427]||(s[427]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">univariate_sampler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(LL, modifier</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BranchlengthPeturbation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, curr_branchlength)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A MCMC algorithm that draws the next sample of a Markov Chain that approximates the Posterior distrubution over the branchlengths.</span></span></code></pre></div>`,1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[426]||(s[426]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/simple_sample.jl#L18-L23",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",pi,[i("summary",null,[s[428]||(s[428]=i("a",{id:"MolecularEvolution.values_from_phylo_tree-Tuple{Any, Any}",href:"#MolecularEvolution.values_from_phylo_tree-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.values_from_phylo_tree")],-1)),s[429]||(s[429]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[431]||(s[431]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">values_from_phylo_tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(phylo_tree, key)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Returns a list of values from the given key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> the nodes of the phylo_tree, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> an order that is somehow compatible with the order the nodes get plotted in.</span></span></code></pre></div>`,1)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[430]||(s[430]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/viz/phylo_glue.jl#L72-L77",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",di,[i("summary",null,[s[432]||(s[432]=i("a",{id:"MolecularEvolution.weightEM-Tuple{Matrix{Float64}, Any}",href:"#MolecularEvolution.weightEM-Tuple{Matrix{Float64}, Any}"},[i("span",{class:"jlbinding"},"MolecularEvolution.weightEM")],-1)),s[433]||(s[433]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[435]||(s[435]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">weightEM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(con_lik_matrix</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Array{Float64,2}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, θ; conc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, iters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Takes a conditional likelihood matrix (#categories-by-sites) and a starting frequency vector θ (length(θ) = #categories) and optimizes θ (using Expectation Maximization. Maybe.). If conc &gt; 0 then this gives something like variational bayes behavior for LDA. Maybe.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[434]||(s[434]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/misc.jl#L40-L45",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",hi,[i("summary",null,[s[436]||(s[436]=i("a",{id:"MolecularEvolution.write_fasta-Tuple{String, Vector{String}}",href:"#MolecularEvolution.write_fasta-Tuple{String, Vector{String}}"},[i("span",{class:"jlbinding"},"MolecularEvolution.write_fasta")],-1)),s[437]||(s[437]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[439]||(s[439]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write_fasta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filepath</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sequences</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{String}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; seq_names </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Writes a fasta file from a vector of sequences, with optional seq_names.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[438]||(s[438]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/fasta_io.jl#L18-L22",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",ui,[i("summary",null,[s[440]||(s[440]=i("a",{id:"MolecularEvolution.write_nexus-Tuple{String, FelNode}",href:"#MolecularEvolution.write_nexus-Tuple{String, FelNode}"},[i("span",{class:"jlbinding"},"MolecularEvolution.write_nexus")],-1)),s[441]||(s[441]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[443]||(s[443]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write_nexus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fname</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Writes the tree as a nexus file, suitable for opening in eg. FigTree. Data in the <code>node_data</code> dictionary will be converted into annotations. Only tested for simple <code>node_data</code> formats and types.</p>',2)),l(e,{type:"info",class:"source-link",text:"source"},{default:a(()=>s[442]||(s[442]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/b237d00e6aa3507bfaf2afe705417874c1b1b4bd/src/utils/misc.jl#L281-L287",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})])])}const fi=o(h,[["render",ki]]);export{_i as __pageData,fi as default};
