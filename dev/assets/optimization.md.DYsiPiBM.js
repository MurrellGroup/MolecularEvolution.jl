import{_ as p,C as h,c as r,o,aA as t,j as i,G as e,a as n,w as l}from"./chunks/framework.DFdHVvAO.js";const _=JSON.parse('{"title":"Optimization","description":"","frontmatter":{},"headers":[],"relativePath":"optimization.md","filePath":"optimization.md","lastUpdated":null}'),k={name:"optimization.md"},d={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""};function y(m,s,b,F,v,f){const a=h("Badge");return o(),r("div",null,[s[21]||(s[21]=t(`<h1 id="optimization" tabindex="-1">Optimization <a class="header-anchor" href="#optimization" aria-label="Permalink to &quot;Optimization&quot;">​</a></h1><p>There are two distinct kinds of optimization: &quot;global&quot; model parameters, and then tree branchlengths and topology. These are kept distinct because we can use algorithmic tricks to dramatically improve the performance of the latter.</p><p>The example below will set up and optimize a <a href="https://en.wikipedia.org/wiki/Substitution_model" target="_blank" rel="noreferrer">&quot;Generalized Time Reversible&quot; nucleotide substitution model</a>, where there are 6 rate parameters that govern the symmetric part of a rate matrix, and 4 nucleotide frequencies (that sum to 1, so only 3 underlying parameters).</p><h2 id="Optimizing-model-parameters" tabindex="-1">Optimizing model parameters <a class="header-anchor" href="#Optimizing-model-parameters" aria-label="Permalink to &quot;Optimizing model parameters {#Optimizing-model-parameters}&quot;">​</a></h2><p>We first need to construct an objective function. A very common use case involves parameterizing a rate matrix (along with all the constraints this entails) from a flat parameter vector. <code>reversibleQ</code> can be convenient here, which takes a vector of parameters and equilibrium frequencies and returns a reversible rate matrix. The parameters are the upper triangle (excluding the diagonal) of the rate matrix:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reversibleQ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>4×4 Matrix{Float64}:</span></span>
<span class="line"><span> -6.0    1.0    2.0    3.0</span></span>
<span class="line"><span>  1.0  -10.0    4.0    5.0</span></span>
<span class="line"><span>  2.0    4.0  -12.0    6.0</span></span>
<span class="line"><span>  3.0    5.0    6.0  -14.0</span></span></code></pre></div><p>...and the equilibrium frequencies are multiplied column-wise:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reversibleQ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>4×4 Matrix{Float64}:</span></span>
<span class="line"><span> -0.9   0.2   0.3   0.4</span></span>
<span class="line"><span>  0.1  -0.8   0.3   0.4</span></span>
<span class="line"><span>  0.1   0.2  -0.7   0.4</span></span>
<span class="line"><span>  0.1   0.2   0.3  -0.6</span></span></code></pre></div><p>Another convenient trick is to be able to parameterize a vector of positive frequencies that sum to 1, using N-1 unconstrained parameters. <code>unc2probvec</code> can help:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">unc2probvec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">zeros</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>4-element Vector{Float64}:</span></span>
<span class="line"><span> 0.25</span></span>
<span class="line"><span> 0.25</span></span>
<span class="line"><span> 0.25</span></span>
<span class="line"><span> 0.25</span></span></code></pre></div><p><a href="https://github.com/invenia/ParameterHandling.jl" target="_blank" rel="noreferrer"><code>ParameterHandling.jl</code></a> provides a convenient framework for managing collections of parameters in a way that plays with much of the Julia optimization ecosystem, and we recommend its use. Here we&#39;ll use <code>ParameterHandling</code> and <a href="https://github.com/JuliaOpt/NLopt.jl" target="_blank" rel="noreferrer"><code>NLopt</code></a>.</p><p>First, we&#39;ll load in some example nucleotide data:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MolecularEvolution, FASTX, ParameterHandling, NLopt</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#Read in seqs and tree, and populate the three  NucleotidePartitions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">seqnames, seqs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> read_fasta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Data/MusNuc_IGHV.fasta&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tree </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> read_newick_tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Data/MusNuc_IGHV.tre&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">initial_partition </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NucleotidePartition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(seqs[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">populate_tree!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree,initial_partition,seqnames,seqs)</span></span></code></pre></div><p>Then we set up the model parameters, and the objective function:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#Named tuple of parameters, with initial values and constraints (from ParameterHandling.jl)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">initial_params </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        rates</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">positive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)), </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#rates must be non-negative</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        pi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">zeros</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#will be transformed into 4 eq freqs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flat_initial_params, unflatten </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> value_flatten</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(initial_params) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#See ParameterHandling.jl docs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">num_params </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flat_initial_params)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#Set up a function that builds a model from these parameters</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> build_model_vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(params)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    pi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unc2probvec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(params</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> DiagonalizedCTMC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reversibleQ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(params</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rates,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#Set up the function to be *minimized*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> objective</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(params</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; tree </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tree)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    #In this example, we are optimizing the nuc equilibrium freqs</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    #We&#39;ll also assume that the starting frequencies (at the root of the tree) are the eq freqs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parent_message[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state .</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unc2probvec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(params</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log_likelihood!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">build_model_vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(params)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#Note, negative of LL, because minimization</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>Then we&#39;ll set up an optimizer from <code>NLOpt</code>. See <a href="https://discourse.julialang.org/t/optim-what-optimiser-is-best-if-your-gradient-computation-is-slow/5487/12" target="_blank" rel="noreferrer">this discussion</a> and <a href="https://github.com/SciML/DiffEqParamEstim.jl/blob/master/test/lorenz_true_test.jl" target="_blank" rel="noreferrer">this exploration</a> of optimizers.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">opt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Opt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:LN_BOBYQA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, num_params)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#Note: NLopt requires a function that returns a gradient, even for gradient free methods, hence (x,y)-&gt;...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">min_objective!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opt, (x,y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (objective </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">∘</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unflatten)(x)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#See ParameterHandling.jl docs for objective ∘ unflatten explanation</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#Some bounds (which will be in the transformed domain) to prevent searching numerically silly bits of parameter space:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lower_bounds!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opt, [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">num_params])</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">upper_bounds!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opt, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">num_params])</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">xtol_rel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opt, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e-12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">_,mini,_ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NLopt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">optimize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opt, flat_initial_params)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">final_params </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unflatten</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mini)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">optimized_model </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> build_model_vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(final_params)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Opt LL:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log_likelihood!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree,optimized_model))</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Opt LL:-3783.226756522292</span></span></code></pre></div><p>We can view the optimized parameter values:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>println(&quot;Rates: &quot;, round.(final_params.rates,sigdigits = 4))</span></span>
<span class="line"><span>println(&quot;Pi:&quot;, round.(unc2probvec(final_params.pi),sigdigits = 4))</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Rates: [1.124, 2.102, 1.075, 0.9802, 1.605, 0.5536]</span></span>
<span class="line"><span>Pi:[0.2796, 0.2192, 0.235, 0.2662]</span></span></code></pre></div><p>Or the entire optimized rate matrix:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">matrix_for_display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(optimized_model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Q,[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;C&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;G&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;T&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Opt LL:-3783.226756522292</span></span>
<span class="line"><span>5×5 Matrix{Any}:</span></span>
<span class="line"><span> &quot;&quot;     &#39;A&#39;        &#39;C&#39;        &#39;G&#39;        &#39;T&#39;</span></span>
<span class="line"><span> &#39;A&#39;  -1.02672    0.246386   0.494024   0.286309</span></span>
<span class="line"><span> &#39;C&#39;   0.314289  -0.971998   0.23034    0.427368</span></span>
<span class="line"><span> &#39;G&#39;   0.587774   0.214842  -0.950007   0.147391</span></span>
<span class="line"><span> &#39;T&#39;   0.300663   0.35183    0.130093  -0.782586</span></span></code></pre></div><h2 id="Optimizing-the-tree-topology-and-branch-lengths" tabindex="-1">Optimizing the tree topology and branch lengths <a class="header-anchor" href="#Optimizing-the-tree-topology-and-branch-lengths" aria-label="Permalink to &quot;Optimizing the tree topology and branch lengths {#Optimizing-the-tree-topology-and-branch-lengths}&quot;">​</a></h2><p>With a tree and a model, we can also optimize the branch lengths and search, by <a href="https://en.wikipedia.org/wiki/Tree_rearrangement" target="_blank" rel="noreferrer">nearest neighbour interchange</a> for changes to the tree that improve the likelihood. Individually, these are performed by <code>nni_optim!</code> and <code>branchlength_optim!</code>, which need to have <code>felsenstein!</code> and <code>felsenstein_down!</code> called beforehand, but this is all bundled into:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tree_polish!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree, optimized_model)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LL: -3783.226756522292</span></span>
<span class="line"><span>LL: -3782.345818028071</span></span>
<span class="line"><span>LL: -3782.3231632207567</span></span>
<span class="line"><span>LL: -3782.3211724011044</span></span>
<span class="line"><span>LL: -3782.321068684831</span></span>
<span class="line"><span>LL: -3782.3210622627776</span></span></code></pre></div><p>And just to convince you this works, we can perturb the branch lengths, and see how the likelihood improves:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> getnodelist</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">branchlength </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tree_polish!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree, optimzed_model)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LL: -3805.4140940138795</span></span>
<span class="line"><span>LL: -3782.884883999107</span></span>
<span class="line"><span>LL: -3782.351780962518</span></span>
<span class="line"><span>LL: -3782.322906364547</span></span>
<span class="line"><span>LL: -3782.321183009534</span></span>
<span class="line"><span>LL: -3782.3210398963506</span></span>
<span class="line"><span>LL: -3782.3210271696703</span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">Warning</p><p><code>tree_polish!</code> probably won&#39;t find a good tree from a completely start. Different tree search heuristics are required for that.</p></div><h2 id="functions" tabindex="-1">Functions <a class="header-anchor" href="#functions" aria-label="Permalink to &quot;Functions&quot;">​</a></h2>`,36)),i("details",d,[i("summary",null,[s[0]||(s[0]=i("a",{id:"MolecularEvolution.reversibleQ",href:"#MolecularEvolution.reversibleQ"},[i("span",{class:"jlbinding"},"MolecularEvolution.reversibleQ")],-1)),s[1]||(s[1]=n()),e(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[3]||(s[3]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reversibleQ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(param_vec,eq_freqs)</span></span></code></pre></div><p>Takes a vector of parameters and equilibrium frequencies and returns a reversible rate matrix. The parameters are the upper triangle of the rate matrix, with the diagonal elements omitted, and the equilibrium frequencies are multiplied column-wise.</p>',2)),e(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[2]||(s[2]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/8edb5e0ce9981f8ff61058f682f6f791eb88f286/src/models/discrete_models/utils/matrix_helpers.jl#L122-L128",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",c,[i("summary",null,[s[4]||(s[4]=i("a",{id:"MolecularEvolution.unc2probvec",href:"#MolecularEvolution.unc2probvec"},[i("span",{class:"jlbinding"},"MolecularEvolution.unc2probvec")],-1)),s[5]||(s[5]=n()),e(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[7]||(s[7]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">unc2probvec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v)</span></span></code></pre></div><p>Takes an array of N-1 unbounded values and returns an array of N values that sums to 1. Typically useful for optimizing over categorical probability distributions.</p>',2)),e(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[6]||(s[6]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/8edb5e0ce9981f8ff61058f682f6f791eb88f286/src/models/discrete_models/utils/matrix_helpers.jl#L177-L181",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",g,[i("summary",null,[s[8]||(s[8]=i("a",{id:"MolecularEvolution.branchlength_optim!",href:"#MolecularEvolution.branchlength_optim!"},[i("span",{class:"jlbinding"},"MolecularEvolution.branchlength_optim!")],-1)),s[9]||(s[9]=n()),e(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[11]||(s[11]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">branchlength_optim!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models;  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Uses golden section search, or optionally Brent&#39;s method, to optimize all branches recursively, maintaining the integrity of the messages. Requires felsenstein!() to have been run first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>partition_list=nothing</code>: (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over (but you probably want to optimize branch lengths with all models, the default option).</p></li><li><p><code>tol=1e-5</code>: absolute tolerance for the <code>bl_optimizer</code>.</p></li><li><p><code>bl_optimizer::UnivariateModifier=GoldenSectionOpt()</code>: the algorithm used to optimize the log likelihood of a branch length. In addition to golden section search, Brent&#39;s method can be used by setting <code>bl_optimizer=BrentsMethodOpt()</code>.</p></li><li><p><code>sort_tree=false</code>: determines if a <a href="/MolecularEvolution.jl/dev/api#MolecularEvolution.lazysort!-Tuple{FelNode}"><code>lazysort!</code></a> will be performed, which can reduce the amount of temporary messages that has to be initialized.</p></li><li><p><code>traversal=Iterators.reverse</code>: a function that determines the traversal, permutes an iterable.</p></li><li><p><code>shuffle=false</code>: do a randomly shuffled traversal, overrides <code>traversal</code>.</p></li></ul>',4)),e(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[10]||(s[10]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/8edb5e0ce9981f8ff61058f682f6f791eb88f286/src/core/algorithms/branchlength_optim.jl#L191-L206",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",u,[i("summary",null,[s[12]||(s[12]=i("a",{id:"MolecularEvolution.nni_optim!",href:"#MolecularEvolution.nni_optim!"},[i("span",{class:"jlbinding"},"MolecularEvolution.nni_optim!")],-1)),s[13]||(s[13]=n()),e(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[15]||(s[15]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nni_optim!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FelNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, models; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Considers local branch swaps for all branches recursively, maintaining the integrity of the messages. Requires felsenstein!() to have been run first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>partition_list=nothing</code>: (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over (but you probably want to optimize tree topology with all models, the default option).</p></li><li><p><code>selection_rule = x -&gt; argmax(x)</code>: a function that takes the current and proposed log likelihoods and selects a nni configuration. Note that the current log likelihood is stored at x[1].</p></li><li><p><code>sort_tree=false</code>: determines if a <a href="/MolecularEvolution.jl/dev/api#MolecularEvolution.lazysort!-Tuple{FelNode}"><code>lazysort!</code></a> will be performed, which can reduce the amount of temporary messages that has to be initialized.</p></li><li><p><code>traversal=Iterators.reverse</code>: a function that determines the traversal, permutes an iterable.</p></li><li><p><code>shuffle=false</code>: do a randomly shuffled traversal, overrides <code>traversal</code>.</p></li></ul>',4)),e(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[14]||(s[14]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/8edb5e0ce9981f8ff61058f682f6f791eb88f286/src/core/algorithms/nni_optim.jl#L323-L337",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i("details",E,[i("summary",null,[s[16]||(s[16]=i("a",{id:"MolecularEvolution.tree_polish!",href:"#MolecularEvolution.tree_polish!"},[i("span",{class:"jlbinding"},"MolecularEvolution.tree_polish!")],-1)),s[17]||(s[17]=n()),e(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[19]||(s[19]=i("p",null,"tree_polish!(newt, models; tol = 10^-4, verbose = 1, topology = true)",-1)),s[20]||(s[20]=i("p",null,[n("Takes a tree and a model function, and optimizes branch lengths and, optionally, topology. Returns final LL. Set "),i("code",null,"verbose=0"),n(" to suppress output. Note: This is not intended for an exhaustive tree search (which requires different heuristics), but rather to polish a tree that is already relatively close to the optimum.")],-1)),e(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[18]||(s[18]=[i("a",{href:"https://github.com/MurrellGroup/MolecularEvolution.jl/blob/8edb5e0ce9981f8ff61058f682f6f791eb88f286/src/utils/misc.jl#L160-L165",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})])])}const A=p(k,[["render",y]]);export{_ as __pageData,A as default};
