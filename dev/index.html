<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MolecularEvolution.jl</title><meta name="title" content="Home · MolecularEvolution.jl"/><meta property="og:title" content="Home · MolecularEvolution.jl"/><meta property="twitter:title" content="Home · MolecularEvolution.jl"/><meta name="description" content="Documentation for MolecularEvolution.jl."/><meta property="og:description" content="Documentation for MolecularEvolution.jl."/><meta property="twitter:description" content="Documentation for MolecularEvolution.jl."/><meta property="og:url" content="https://MurrellGroup.github.io/MolecularEvolution.jl/"/><meta property="twitter:url" content="https://MurrellGroup.github.io/MolecularEvolution.jl/"/><link rel="canonical" href="https://MurrellGroup.github.io/MolecularEvolution.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="MolecularEvolution.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>MolecularEvolution.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="framework/">The MolecularEvolution.jl Framework</a></li><li><a class="tocitem" href="examples/">Examples</a></li><li><a class="tocitem" href="IO/">Input/Output</a></li><li><a class="tocitem" href="models/">Models</a></li><li><a class="tocitem" href="simulation/">Simulation</a></li><li><a class="tocitem" href="optimization/">Optimization</a></li><li><a class="tocitem" href="ancestors/">Ancestral Reconstruction</a></li><li><a class="tocitem" href="viz/">Visualization</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MolecularEvolution"><a class="docs-heading-anchor" href="#MolecularEvolution">MolecularEvolution</a><a id="MolecularEvolution-1"></a><a class="docs-heading-anchor-permalink" href="#MolecularEvolution" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/MurrellGroup/MolecularEvolution.jl">MolecularEvolution</a>.</p><h3 id="A-Julia-package-for-the-flexible-development-of-phylogenetic-models."><a class="docs-heading-anchor" href="#A-Julia-package-for-the-flexible-development-of-phylogenetic-models.">A Julia package for the flexible development of phylogenetic models.</a><a id="A-Julia-package-for-the-flexible-development-of-phylogenetic-models.-1"></a><a class="docs-heading-anchor-permalink" href="#A-Julia-package-for-the-flexible-development-of-phylogenetic-models." title="Permalink"></a></h3><p>MolecularEvolution.jl exploits Julia&#39;s multiple dispatch, implementing a fully generic suite of likelihood calculations, branchlength optimization, topology optimization, and ancestral inference. Users can construct trees using already-defined data types and models. But users can define probability distributions over their own data types, and specify the behavior of these under their own model types, and can mix and match different models on the same phylogeny.</p><p>If the behavior you need is not already available in <code>MolecularEvolution.jl</code>:</p><ul><li>If you have a new data type:<ul><li>A <code>Partition</code> type that represents the uncertainty over your state. </li><li><code>combine!()</code> that merges evidence from two <code>Partition</code>s.</li></ul></li><li>If you have a new model:<ul><li>A <code>BranchModel</code> type that stores your model parameters.</li><li><code>forward!()</code> that evolves state distributions over branches, in the root-to-tip direction.</li><li><code>backward!()</code> that reverse-evolves state distributions over branches, in the tip-to-root direction.</li></ul></li></ul><p>And then sampling, likelihood calculations, branch-length optimization, ancestral reconstruction, etc should be available for your new data or model.</p><h3 id="Design-principles"><a class="docs-heading-anchor" href="#Design-principles">Design principles</a><a id="Design-principles-1"></a><a class="docs-heading-anchor-permalink" href="#Design-principles" title="Permalink"></a></h3><p>In order of importance, we aim for the following:</p><ul><li>Flexibility and generality<ul><li>Where possible, we avoid design decisions that limit the development of new models, or make it harder to develop new models.</li><li>We do not sacrifice flexibility for performance.</li></ul></li><li>Scalability<ul><li>Analyses implemented using <code>MolecularEvolution.jl</code> should scale to large, real-world datasets.</li></ul></li><li>Performance<ul><li>While the above take precedence over speed, it should be possible to optimize your <code>Partition</code>, <code>combine!()</code>, <code>BranchModel</code>, <code>forward!()</code> and <code>backward!()</code> functions to obtain competative runtimes.</li></ul></li></ul><h3 id="Authors:"><a class="docs-heading-anchor" href="#Authors:">Authors:</a><a id="Authors:-1"></a><a class="docs-heading-anchor-permalink" href="#Authors:" title="Permalink"></a></h3><p>Venkatesh Kumar and Ben Murrell, with additional contributions by Sanjay Mohan, Alec Pankow, Hassan Sadiq, and Kenta Sato.</p><h3 id="Quick-example:-Likelihood-calculations-under-phylogenetic-Brownian-motion:"><a class="docs-heading-anchor" href="#Quick-example:-Likelihood-calculations-under-phylogenetic-Brownian-motion:">Quick example: Likelihood calculations under phylogenetic Brownian motion:</a><a id="Quick-example:-Likelihood-calculations-under-phylogenetic-Brownian-motion:-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-example:-Likelihood-calculations-under-phylogenetic-Brownian-motion:" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MolecularEvolution, Plots

#First simulate a tree, using a coalescent process
tree = sim_tree(n=200)
internal_message_init!(tree, GaussianPartition())
#Simulate brownian motion over the tree
bm_model = BrownianMotion(0.0,1.0)
sample_down!(tree, bm_model)
#And plot the log likelihood as a function of the parameter value
ll(x) = log_likelihood!(tree,BrownianMotion(0.0,x))
plot(0.7:0.001:1.6,ll, xlabel = &quot;variance per unit time&quot;, ylabel = &quot;log likelihood&quot;)</code></pre><p><img src="figures/quick_example.svg" alt/></p><ul><li><a href="#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode"><code>Base.:==</code></a></li><li><a href="#MolecularEvolution.SWM_prob_grid-Union{Tuple{SWMPartition{PType}}, Tuple{PType}} where PType&lt;:MultiSitePartition"><code>MolecularEvolution.SWM_prob_grid</code></a></li><li><a href="#MolecularEvolution._mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any, Any}} where T&lt;:Function"><code>MolecularEvolution._mapreduce</code></a></li><li><a href="framework/#MolecularEvolution.backward!"><code>MolecularEvolution.backward!</code></a></li><li><a href="#MolecularEvolution.backward!-Tuple{DiscretePartition, DiscretePartition, GeneralCTMC, FelNode}"><code>MolecularEvolution.backward!</code></a></li><li><a href="#MolecularEvolution.bfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function"><code>MolecularEvolution.bfs_mapreduce</code></a></li><li><a href="#MolecularEvolution.branchlength_optim!-Tuple{FelNode, Any}"><code>MolecularEvolution.branchlength_optim!</code></a></li><li><a href="optimization/#MolecularEvolution.branchlength_optim!"><code>MolecularEvolution.branchlength_optim!</code></a></li><li><a href="#MolecularEvolution.brents_method_minimize-Tuple{Any, Real, Real, Any, Real}"><code>MolecularEvolution.brents_method_minimize</code></a></li><li><a href="#MolecularEvolution.cascading_max_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.cascading_max_state_dict</code></a></li><li><a href="ancestors/#MolecularEvolution.cascading_max_state_dict"><code>MolecularEvolution.cascading_max_state_dict</code></a></li><li><a href="#MolecularEvolution.char_proportions-Tuple{Any, String}"><code>MolecularEvolution.char_proportions</code></a></li><li><a href="#MolecularEvolution.colored_seq_draw-Tuple{Any, Any, AbstractString}"><code>MolecularEvolution.colored_seq_draw</code></a></li><li><a href="framework/#MolecularEvolution.combine!"><code>MolecularEvolution.combine!</code></a></li><li><a href="#MolecularEvolution.combine!-Tuple{DiscretePartition, DiscretePartition}"><code>MolecularEvolution.combine!</code></a></li><li><a href="#MolecularEvolution.deepequals-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode"><code>MolecularEvolution.deepequals</code></a></li><li><a href="#MolecularEvolution.dfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function"><code>MolecularEvolution.dfs_mapreduce</code></a></li><li><a href="#MolecularEvolution.discrete_name_color_dict-Tuple{AbstractTreeNode, Any}"><code>MolecularEvolution.discrete_name_color_dict</code></a></li><li><a href="#MolecularEvolution.draw_example_tree-Tuple{}"><code>MolecularEvolution.draw_example_tree</code></a></li><li><a href="#MolecularEvolution.endpoint_conditioned_sample_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.endpoint_conditioned_sample_state_dict</code></a></li><li><a href="ancestors/#MolecularEvolution.endpoint_conditioned_sample_state_dict"><code>MolecularEvolution.endpoint_conditioned_sample_state_dict</code></a></li><li><a href="#MolecularEvolution.expected_subs_per_site-Tuple{Any, Any}"><code>MolecularEvolution.expected_subs_per_site</code></a></li><li><a href="#MolecularEvolution.felsenstein!-Tuple{FelNode, Any}"><code>MolecularEvolution.felsenstein!</code></a></li><li><a href="#MolecularEvolution.felsenstein_down!-Tuple{FelNode, Any}"><code>MolecularEvolution.felsenstein_down!</code></a></li><li><a href="#MolecularEvolution.forward!-Tuple{DiscretePartition, DiscretePartition, GeneralCTMC, FelNode}"><code>MolecularEvolution.forward!</code></a></li><li><a href="framework/#MolecularEvolution.forward!"><code>MolecularEvolution.forward!</code></a></li><li><a href="#MolecularEvolution.gappy_Q_from_symmetric_rate_matrix-Tuple{Any, Any, Any}"><code>MolecularEvolution.gappy_Q_from_symmetric_rate_matrix</code></a></li><li><a href="#MolecularEvolution.get_highlighter_legend-Tuple{Any}"><code>MolecularEvolution.get_highlighter_legend</code></a></li><li><a href="#MolecularEvolution.get_max_depth-Tuple{Any, Real}"><code>MolecularEvolution.get_max_depth</code></a></li><li><a href="#MolecularEvolution.get_phylo_tree-Tuple{FelNode}"><code>MolecularEvolution.get_phylo_tree</code></a></li><li><a href="viz/#MolecularEvolution.get_phylo_tree"><code>MolecularEvolution.get_phylo_tree</code></a></li><li><a href="#MolecularEvolution.golden_section_maximize-Tuple{Any, Real, Real, Any, Real}"><code>MolecularEvolution.golden_section_maximize</code></a></li><li><a href="#MolecularEvolution.highlight_seq_draw-Tuple{Any, Any, AbstractString, Any, Any, Any}"><code>MolecularEvolution.highlight_seq_draw</code></a></li><li><a href="#MolecularEvolution.highlighter_tree_draw-NTuple{4, Any}"><code>MolecularEvolution.highlighter_tree_draw</code></a></li><li><a href="#MolecularEvolution.internal_message_init!-Tuple{FelNode, Vector{&lt;:Partition}}"><code>MolecularEvolution.internal_message_init!</code></a></li><li><a href="#MolecularEvolution.internal_message_init!-Tuple{FelNode, Partition}"><code>MolecularEvolution.internal_message_init!</code></a></li><li><a href="#MolecularEvolution.istreeconsistent-Tuple{T} where T&lt;:AbstractTreeNode"><code>MolecularEvolution.istreeconsistent</code></a></li><li><a href="#MolecularEvolution.linear_scale-NTuple{5, Any}"><code>MolecularEvolution.linear_scale</code></a></li><li><a href="#MolecularEvolution.log_likelihood-Tuple{FelNode, BranchModel}"><code>MolecularEvolution.log_likelihood</code></a></li><li><a href="#MolecularEvolution.log_likelihood!-Tuple{FelNode, Any}"><code>MolecularEvolution.log_likelihood!</code></a></li><li><a href="#MolecularEvolution.longest_path-Tuple{FelNode}"><code>MolecularEvolution.longest_path</code></a></li><li><a href="ancestors/#MolecularEvolution.marginal_state_dict"><code>MolecularEvolution.marginal_state_dict</code></a></li><li><a href="#MolecularEvolution.marginal_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.marginal_state_dict</code></a></li><li><a href="#MolecularEvolution.matrix_for_display-Tuple{Any, Any}"><code>MolecularEvolution.matrix_for_display</code></a></li><li><a href="#MolecularEvolution.midpoint-Tuple{FelNode}"><code>MolecularEvolution.midpoint</code></a></li><li><a href="#MolecularEvolution.mix-Union{Tuple{SWMPartition{PType}}, Tuple{PType}} where PType&lt;:DiscretePartition"><code>MolecularEvolution.mix</code></a></li><li><a href="#MolecularEvolution.name2node_dict-Tuple{AbstractTreeNode}"><code>MolecularEvolution.name2node_dict</code></a></li><li><a href="#MolecularEvolution.newick-Tuple{AbstractTreeNode}"><code>MolecularEvolution.newick</code></a></li><li><a href="IO/#MolecularEvolution.newick"><code>MolecularEvolution.newick</code></a></li><li><a href="#MolecularEvolution.nni_optim!-Tuple{FelNode, Any}"><code>MolecularEvolution.nni_optim!</code></a></li><li><a href="optimization/#MolecularEvolution.nni_optim!"><code>MolecularEvolution.nni_optim!</code></a></li><li><a href="#MolecularEvolution.node_distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.node_distances</code></a></li><li><a href="#MolecularEvolution.nonreversibleQ-Tuple{Any}"><code>MolecularEvolution.nonreversibleQ</code></a></li><li><a href="#MolecularEvolution.parent_list-Tuple{FelNode}"><code>MolecularEvolution.parent_list</code></a></li><li><a href="#MolecularEvolution.partition2obs-Tuple{DiscretePartition, String}"><code>MolecularEvolution.partition2obs</code></a></li><li><a href="simulation/#MolecularEvolution.partition2obs"><code>MolecularEvolution.partition2obs</code></a></li><li><a href="#MolecularEvolution.populate_tree!-Tuple{FelNode, Partition, Any, Any}"><code>MolecularEvolution.populate_tree!</code></a></li><li><a href="IO/#MolecularEvolution.populate_tree!"><code>MolecularEvolution.populate_tree!</code></a></li><li><a href="#MolecularEvolution.promote_internal-Tuple{FelNode}"><code>MolecularEvolution.promote_internal</code></a></li><li><a href="#MolecularEvolution.quadratic_CI-Tuple{Function, Vector, Int64}"><code>MolecularEvolution.quadratic_CI</code></a></li><li><a href="#MolecularEvolution.quadratic_CI-Tuple{Vector, Vector}"><code>MolecularEvolution.quadratic_CI</code></a></li><li><a href="#MolecularEvolution.read_fasta-Tuple{String}"><code>MolecularEvolution.read_fasta</code></a></li><li><a href="IO/#MolecularEvolution.read_fasta"><code>MolecularEvolution.read_fasta</code></a></li><li><a href="#MolecularEvolution.read_newick_tree-Tuple{String}"><code>MolecularEvolution.read_newick_tree</code></a></li><li><a href="IO/#MolecularEvolution.read_newick_tree"><code>MolecularEvolution.read_newick_tree</code></a></li><li><a href="optimization/#MolecularEvolution.reversibleQ"><code>MolecularEvolution.reversibleQ</code></a></li><li><a href="#MolecularEvolution.reversibleQ-Tuple{Any, Any}"><code>MolecularEvolution.reversibleQ</code></a></li><li><a href="#MolecularEvolution.root2tip_distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.root2tip_distances</code></a></li><li><a href="simulation/#MolecularEvolution.sample_down!"><code>MolecularEvolution.sample_down!</code></a></li><li><a href="#MolecularEvolution.sample_down!-Tuple{FelNode, Any, Any}"><code>MolecularEvolution.sample_down!</code></a></li><li><a href="#MolecularEvolution.sample_from_message!-Tuple{Vector{&lt;:Partition}}"><code>MolecularEvolution.sample_from_message!</code></a></li><li><a href="#MolecularEvolution.savefig_tweakSVG-Tuple{Any, Plots.Plot}"><code>MolecularEvolution.savefig_tweakSVG</code></a></li><li><a href="#MolecularEvolution.savefig_tweakSVG-Tuple{Any, Context}"><code>MolecularEvolution.savefig_tweakSVG</code></a></li><li><a href="viz/#MolecularEvolution.savefig_tweakSVG"><code>MolecularEvolution.savefig_tweakSVG</code></a></li><li><a href="#MolecularEvolution.shortest_path_between_nodes-Tuple{FelNode, FelNode}"><code>MolecularEvolution.shortest_path_between_nodes</code></a></li><li><a href="#MolecularEvolution.sibling_inds-Tuple{AbstractTreeNode}"><code>MolecularEvolution.sibling_inds</code></a></li><li><a href="#MolecularEvolution.siblings-Tuple{AbstractTreeNode}"><code>MolecularEvolution.siblings</code></a></li><li><a href="simulation/#MolecularEvolution.sim_tree"><code>MolecularEvolution.sim_tree</code></a></li><li><a href="#MolecularEvolution.sim_tree-Tuple{Int64, Any, Any}"><code>MolecularEvolution.sim_tree</code></a></li><li><a href="#MolecularEvolution.sim_tree-Tuple{}"><code>MolecularEvolution.sim_tree</code></a></li><li><a href="#MolecularEvolution.simple_radial_tree_plot-Tuple{FelNode}"><code>MolecularEvolution.simple_radial_tree_plot</code></a></li><li><a href="#MolecularEvolution.simple_tree_draw-Tuple{FelNode}"><code>MolecularEvolution.simple_tree_draw</code></a></li><li><a href="#MolecularEvolution.total_LL-Tuple{Partition}"><code>MolecularEvolution.total_LL</code></a></li><li><a href="#MolecularEvolution.tree2distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.tree2distances</code></a></li><li><a href="#MolecularEvolution.tree2shared_branch_lengths-Tuple{AbstractTreeNode}"><code>MolecularEvolution.tree2shared_branch_lengths</code></a></li><li><a href="#MolecularEvolution.tree_draw-Tuple{FelNode}"><code>MolecularEvolution.tree_draw</code></a></li><li><a href="viz/#MolecularEvolution.tree_draw"><code>MolecularEvolution.tree_draw</code></a></li><li><a href="optimization/#MolecularEvolution.tree_polish!"><code>MolecularEvolution.tree_polish!</code></a></li><li><a href="#MolecularEvolution.tree_polish!-Tuple{Any, Any}"><code>MolecularEvolution.tree_polish!</code></a></li><li><a href="#MolecularEvolution.unc2probvec-Tuple{Any}"><code>MolecularEvolution.unc2probvec</code></a></li><li><a href="optimization/#MolecularEvolution.unc2probvec"><code>MolecularEvolution.unc2probvec</code></a></li><li><a href="#MolecularEvolution.univariate_maximize-Tuple{Any, Real, Real, Any, GoldenSectionOpt, Real}"><code>MolecularEvolution.univariate_maximize</code></a></li><li><a href="#MolecularEvolution.univariate_maximize-Tuple{Any, Real, Real, Any, BrentsMethodOpt, Real}"><code>MolecularEvolution.univariate_maximize</code></a></li><li><a href="viz/#MolecularEvolution.values_from_phylo_tree"><code>MolecularEvolution.values_from_phylo_tree</code></a></li><li><a href="#MolecularEvolution.values_from_phylo_tree-Tuple{Any, Any}"><code>MolecularEvolution.values_from_phylo_tree</code></a></li><li><a href="#MolecularEvolution.weightEM-Tuple{Matrix{Float64}, Any}"><code>MolecularEvolution.weightEM</code></a></li><li><a href="IO/#MolecularEvolution.write_fasta"><code>MolecularEvolution.write_fasta</code></a></li><li><a href="#MolecularEvolution.write_fasta-Tuple{String, Vector{String}}"><code>MolecularEvolution.write_fasta</code></a></li><li><a href="IO/#MolecularEvolution.write_nexus"><code>MolecularEvolution.write_nexus</code></a></li><li><a href="#MolecularEvolution.write_nexus-Tuple{String, FelNode}"><code>MolecularEvolution.write_nexus</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode" href="#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(t1, t2)
Defaults to pointer equality</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/AbstractTreeNode.jl#L78-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.SWM_prob_grid-Union{Tuple{SWMPartition{PType}}, Tuple{PType}} where PType&lt;:MultiSitePartition" href="#MolecularEvolution.SWM_prob_grid-Union{Tuple{SWMPartition{PType}}, Tuple{PType}} where PType&lt;:MultiSitePartition"><code>MolecularEvolution.SWM_prob_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SWM_prob_grid(part::SWMPartition{PType}) where {PType &lt;: MultiSitePartition}</code></pre><p>Returns a matrix of probabilities for each site, for each model (in the probability domain - not logged!) as well as the log probability offsets</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/models/compound_models/swm.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution._mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any, Any}} where T&lt;:Function" href="#MolecularEvolution._mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any, Any}} where T&lt;:Function"><code>MolecularEvolution._mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Internal function. Helper for bfs<em>mapreduce and dfs</em>mapreduce</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/base_tree_utils.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.backward!-Tuple{DiscretePartition, DiscretePartition, GeneralCTMC, FelNode}" href="#MolecularEvolution.backward!-Tuple{DiscretePartition, DiscretePartition, GeneralCTMC, FelNode}"><code>MolecularEvolution.backward!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">backward!(dest::Partition, source::Partition, model::BranchModel, node::FelNode)</code></pre><p>Propagate the source partition backwards along the branch to the destination partition, under the model. Note: You should overload this for your own BranchModel types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/models/discrete_models/GeneralCTMC.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.bfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function" href="#MolecularEvolution.bfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function"><code>MolecularEvolution.bfs_mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Performs a BFS map-reduce over the tree, starting at a given node For each node, map<em>reduce is called as:    map</em>reduce(curr<em>node::FelNode, prev</em>node::FelNode, aggregator) where prev_node is the previous node visited on the path from the start node to the current node It is expected to update the aggregator, and not return anything.</p><p>Not exactly conventional map-reduce, as map-reduce calls may rely on state in the aggregator added by map-reduce calls on other nodes visited earlier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/base_tree_utils.jl#L27-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.branchlength_optim!-Tuple{FelNode, Any}" href="#MolecularEvolution.branchlength_optim!-Tuple{FelNode, Any}"><code>MolecularEvolution.branchlength_optim!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">branchlength_optim!(tree::FelNode, models; partition_list = nothing, tol = 1e-5, bl_optimizer::UnivariateOpt = GoldenSectionOpt())</code></pre><p>Uses golden section search, or optionally Brent&#39;s method, to optimize all branches recursively, maintaining the integrity of the messages. Requires felsenstein!() to have been run first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition<em>list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over (but you probably want to optimize branch lengths with all models). tol is the absolute tolerance for the bl</em>optimizer which defaults to golden section search, and has Brent&#39;s method as an option by setting bl_optimizer=BrentsMethodOpt().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/algorithms/branchlength_optim.jl#L92-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.brents_method_minimize-Tuple{Any, Real, Real, Any, Real}" href="#MolecularEvolution.brents_method_minimize-Tuple{Any, Real, Real, Any, Real}"><code>MolecularEvolution.brents_method_minimize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">brents_method_minimize(f, a::Real, b::Real, transform, t::Real; ε::Real=sqrt(eps()))</code></pre><p>Brent&#39;s method for minimization.</p><p>Given a function f with a single local minimum in the interval (a,b), Brent&#39;s method returns an approximation of the x-value that minimizes f to an accuaracy between 2tol and 3tol, where tol is a combination of a relative and an absolute tolerance, tol := ε|x| + t. ε should be no smaller <code>2*eps</code>, and preferably not much less than <code>sqrt(eps)</code>, which is also the default value. eps is defined here as the machine epsilon in double precision. t should be positive.</p><p>The method combines the stability of a Golden Section Search and the superlinear convergence Successive Parabolic Interpolation has under certain conditions. The method never converges much slower than a Fibonacci search and for a sufficiently well-behaved f, convergence can be exptected to be superlinear, with an order that&#39;s usually atleast 1.3247...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = exp(-x) - cos(x)
f (generic function with 1 method)

julia&gt; m = brents_method_minimize(f, -1, 2, identity, 1e-7)
0.5885327257940255</code></pre><p>From: Richard P. Brent, &quot;Algorithms for Minimization without Derivatives&quot; (1973). Chapter 5.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/simple_optim.jl#L106-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.cascading_max_state_dict-Tuple{FelNode, Any}" href="#MolecularEvolution.cascading_max_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.cascading_max_state_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cascading_max_state_dict(tree::FelNode, model; partition_list = 1:length(tree.message), node_message_dict = Dict{FelNode,Vector{Partition}}())</code></pre><p>Takes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode-&gt;Array{&lt;:BranchModel}), and returns a dictionary mapping nodes to their inferred ancestors under the following scheme: the state that maximizes the marginal likelihood is selected at the root, and then, for each node, the maximum likelihood state is selected conditioned on the maximized state of the parent node and the observations of all descendents. A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you&#39;re running this over and over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/algorithms/ancestors.jl#L175-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.char_proportions-Tuple{Any, String}" href="#MolecularEvolution.char_proportions-Tuple{Any, String}"><code>MolecularEvolution.char_proportions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">char_proportions(seqs, alphabet::String)</code></pre><p>Takes a vector of sequences and returns a vector of the proportion of each character across all sequences. An example <code>alphabet</code> argument is <code>MolecularEvolution.AAstring</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/models/discrete_models/utils/matrix_helpers.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.colored_seq_draw-Tuple{Any, Any, AbstractString}" href="#MolecularEvolution.colored_seq_draw-Tuple{Any, Any, AbstractString}"><code>MolecularEvolution.colored_seq_draw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">colored_seq_draw(x, y, str::AbstractString; color_dict=Dict(), font_size=8pt, posx=hcenter, posy=vcenter)</code></pre><p>Draw an arbitrary sequence. <code>color_dict</code> gives a mapping from characters to colors (default black). Default options for nucleotide colorings and amino acid colorings are given in the constants <code>NUC_COLORS</code> and <code>AA_COLORS</code>. This can be used along with <code>compose_dict</code> for drawing sequences at nodes in a tree (see <code>tree_draw</code>). Returns a Compose container.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/tree_compose.jl#L696-L704">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.combine!-Tuple{DiscretePartition, DiscretePartition}" href="#MolecularEvolution.combine!-Tuple{DiscretePartition, DiscretePartition}"><code>MolecularEvolution.combine!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">combine!(dest::P, src::P) where P&lt;:Partition</code></pre><p>Combines evidence from two partitions of the same type, storing the result in dest. Note: You should overload this for your own Partititon types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/models/discrete_models/discrete_partitions.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.deepequals-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode" href="#MolecularEvolution.deepequals-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode"><code>MolecularEvolution.deepequals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deepequals(t1, t2)</code></pre><p>Checks whether two trees are equal by recursively calling this on all fields, except <code>:parent</code>, in order to prevent cycles. In order to ensure that the <code>:parent</code> field is not hiding something different on both trees, ensure that each is consistent first (see: <code>istreeconsistent</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/AbstractTreeNode.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.dfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function" href="#MolecularEvolution.dfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function"><code>MolecularEvolution.dfs_mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Performs a DFS map-reduce over the tree, starting at a given node See bfs_mapreduce for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/base_tree_utils.jl#L46-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.discrete_name_color_dict-Tuple{AbstractTreeNode, Any}" href="#MolecularEvolution.discrete_name_color_dict-Tuple{AbstractTreeNode, Any}"><code>MolecularEvolution.discrete_name_color_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">discrete_name_color_dict(newt::AbstractTreeNode,tag_func; rainbow = false, scramble = false, darken = true, col_seed = nothing)</code></pre><p>Takes a tree and a tag_func, which converts the leaf label into a category (ie. there should be &lt;20 of these), and returns a color dictionary that can be used to color the leaves or bubbles.</p><p>Example tag<em>func:     function tag</em>func(nam::String)         return split(nam,&quot;_&quot;)[1]     end</p><p>For prettier colors, but less discrimination: rainbow = true To randomize the rainbow color assignment: scramble = true col_seed is currently set to white, and excluded from the list of colors, to make them more visible.</p><p>Consider making your own version of this function to customize colors as you see fit.</p><p>Example use: num<em>leaves = 50 Ne</em>func(t) = 1*(e^-t).+5.0 newt = sim<em>tree(num</em>leaves,Ne<em>func,1.0,nstart = rand(1:num</em>leaves)); newt = ladderize(newt) tag<em>func(nam) = mod(sum(Int.(collect(nam))),7) dic = discrete</em>name<em>color</em>dict(newt,tag<em>func,rainbow = true); tree</em>draw(newt,line<em>width = 0.5mm,label</em>color_dict = dic)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/tree_compose.jl#L511-L536">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.draw_example_tree-Tuple{}" href="#MolecularEvolution.draw_example_tree-Tuple{}"><code>MolecularEvolution.draw_example_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_example_tree(num_leaves = 50)</code></pre><p>Draws a tree and shows the code that draws it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/tree_compose.jl#L576-L580">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.endpoint_conditioned_sample_state_dict-Tuple{FelNode, Any}" href="#MolecularEvolution.endpoint_conditioned_sample_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.endpoint_conditioned_sample_state_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">endpoint_conditioned_sample_state_dict(tree::FelNode, model; partition_list = 1:length(tree.message), node_message_dict = Dict{FelNode,Vector{Partition}}())</code></pre><p>Takes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode-&gt;Array{&lt;:BranchModel}), and draws samples under the model conditions on the leaf observations. These samples are stored in the node<em>message</em>dict, which is returned. A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you&#39;re running this over and over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/algorithms/ancestors.jl#L208-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.expected_subs_per_site-Tuple{Any, Any}" href="#MolecularEvolution.expected_subs_per_site-Tuple{Any, Any}"><code>MolecularEvolution.expected_subs_per_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expected_subs_per_site(Q,mu)</code></pre><p>Takes a rate matrix Q and an equilibrium frequency vector, and calculates the expected number of substitutions per site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/misc.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.felsenstein!-Tuple{FelNode, Any}" href="#MolecularEvolution.felsenstein!-Tuple{FelNode, Any}"><code>MolecularEvolution.felsenstein!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">felsenstein!(node::FelNode, models; partition_list = nothing)</code></pre><p>Should usually be called on the root of the tree. Propagates Felsenstein pass up from the tips to the root. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/algorithms/felsenstein.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.felsenstein_down!-Tuple{FelNode, Any}" href="#MolecularEvolution.felsenstein_down!-Tuple{FelNode, Any}"><code>MolecularEvolution.felsenstein_down!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">felsenstein_down!(node::FelNode, models; partition_list = 1:length(tree.message), temp_message = copy_message(tree.message))</code></pre><p>Should usually be called on the root of the tree. Propagates Felsenstein pass down from the root to the tips. felsenstein!() should usually be called first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/algorithms/felsenstein.jl#L78-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.forward!-Tuple{DiscretePartition, DiscretePartition, GeneralCTMC, FelNode}" href="#MolecularEvolution.forward!-Tuple{DiscretePartition, DiscretePartition, GeneralCTMC, FelNode}"><code>MolecularEvolution.forward!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forward!(dest::Partition, source::Partition, model::BranchModel, node::FelNode)</code></pre><p>Propagate the source partition forwards along the branch to the destination partition, under the model. Note: You should overload this for your own BranchModel types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/models/discrete_models/GeneralCTMC.jl#L26-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.gappy_Q_from_symmetric_rate_matrix-Tuple{Any, Any, Any}" href="#MolecularEvolution.gappy_Q_from_symmetric_rate_matrix-Tuple{Any, Any, Any}"><code>MolecularEvolution.gappy_Q_from_symmetric_rate_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gappy_Q_from_symmetric_rate_matrix(sym_mat, gap_rate, eq_freqs)</code></pre><p>Takes a symmetric rate matrix and gap rate (governing mutations to and from gaps) and returns a gappy rate matrix. The equilibrium frequencies are multiplied on column-wise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/models/discrete_models/utils/matrix_helpers.jl#L101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.get_highlighter_legend-Tuple{Any}" href="#MolecularEvolution.get_highlighter_legend-Tuple{Any}"><code>MolecularEvolution.get_highlighter_legend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_highlighter_legend(legend_colors)</code></pre><p>Returns a Compose object given an input dictionary or pairs mapping characters to colors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/tree_compose.jl#L807-L811">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.get_max_depth-Tuple{Any, Real}" href="#MolecularEvolution.get_max_depth-Tuple{Any, Real}"><code>MolecularEvolution.get_max_depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_max_depth(node,depth::Real)</code></pre><p>Return the maximum depth of all children starting from the indicated node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/tree_compose.jl#L791-L795">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.get_phylo_tree-Tuple{FelNode}" href="#MolecularEvolution.get_phylo_tree-Tuple{FelNode}"><code>MolecularEvolution.get_phylo_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_phylo_tree(molev_root::FelNode; data_function = (x -&gt; Tuple{String,Float64}[]))</code></pre><p>Converts a FelNode tree to a Phylo tree. The <code>data_function</code> should return a list of tuples of the form (key, value) to be added to the Phylo tree <code>data</code> Dictionary. Any key/value pairs on the FelNode <code>node_data</code> Dict will also be added to the Phylo tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/phylo_glue.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.golden_section_maximize-Tuple{Any, Real, Real, Any, Real}" href="#MolecularEvolution.golden_section_maximize-Tuple{Any, Real, Real, Any, Real}"><code>MolecularEvolution.golden_section_maximize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Golden section search.</p><p>Given a function f with a single local minimum in the interval [a,b], gss returns a subset interval [c,d] that contains the minimum with d-c &lt;= tol.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = -(x-2)^2
f (generic function with 1 method)

julia&gt; m = golden_section_maximize(f, 1, 5, identity, 1e-10)
2.0000000000051843</code></pre><p>From: https://en.wikipedia.org/wiki/Golden-section_search</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/simple_optim.jl#L18-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.highlight_seq_draw-Tuple{Any, Any, AbstractString, Any, Any, Any}" href="#MolecularEvolution.highlight_seq_draw-Tuple{Any, Any, AbstractString, Any, Any, Any}"><code>MolecularEvolution.highlight_seq_draw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">highlight_seq_draw(x, y, str::AbstractString, region, basecolor, hicolor; fontsize=8pt, posx=hcenter, posy=vcenter)</code></pre><p>Draw a sequence, highlighting the sites given in <code>region</code>. This can be used along with <code>compose_dict</code> for drawing sequences at nodes in a tree (see <code>tree_draw</code>). Returns a Compose container.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/tree_compose.jl#L641-L647">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.highlighter_tree_draw-NTuple{4, Any}" href="#MolecularEvolution.highlighter_tree_draw-NTuple{4, Any}"><code>MolecularEvolution.highlighter_tree_draw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">highlighter_tree_draw(tree, ali_seqs, seqnames, master;
    highlighter_start = 1.1, highlighter_width = 1,
    coord_width = highlighter_start + highlighter_width + 0.1,
    scale_length = nothing, major_breaks = 1000, minor_breaks = 500,
    tree_args = NamedTuple[], legend_padding = 0.5cm, legend_colors = NUC_colors)</code></pre><p>Draws a combined tree and highlighter plot. The vector of seqnames must match the node names in <code>tree</code>.</p><p>kwargs:</p><ul><li>tree<em>args: kwargs to pass to `tree</em>draw()`</li><li>legend<em>colors: Mapping of characters to highlighter colors (default NT</em>colors)</li><li>scale_length: Length of the scale bar</li><li>highlighter_start: Canvas start for the highlighter panel</li><li>highlighter_width: Canvas width for the highlighter panel</li><li>coord_width: Total width of the canvas</li><li>major_breaks: Numbered breaks for sequence axis</li><li>minor_breaks: Ticks for sequence axis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/tree_compose.jl#L888-L907">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.internal_message_init!-Tuple{FelNode, Partition}" href="#MolecularEvolution.internal_message_init!-Tuple{FelNode, Partition}"><code>MolecularEvolution.internal_message_init!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">internal_message_init!(tree::FelNode, partition::Partition)

Initializes the message template for each node in the tree, as an array of the partition.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/FelNode.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.internal_message_init!-Tuple{FelNode, Vector{&lt;:Partition}}" href="#MolecularEvolution.internal_message_init!-Tuple{FelNode, Vector{&lt;:Partition}}"><code>MolecularEvolution.internal_message_init!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">internal_message_init!(tree::FelNode, empty_message::Vector{&lt;:Partition})

Initializes the message template for each node in the tree, allocating space for each partition.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/FelNode.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.istreeconsistent-Tuple{T} where T&lt;:AbstractTreeNode" href="#MolecularEvolution.istreeconsistent-Tuple{T} where T&lt;:AbstractTreeNode"><code>MolecularEvolution.istreeconsistent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">istreeconsistent(root)</code></pre><p>Checks whether the <code>:parent</code> field is set to be consistent with the <code>:child</code> field for all nodes in the subtree. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/AbstractTreeNode.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.linear_scale-NTuple{5, Any}" href="#MolecularEvolution.linear_scale-NTuple{5, Any}"><code>MolecularEvolution.linear_scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linear_scale(val,in_min,in_max,out_min,out_max)</code></pre><p>Linearly maps val which lives in [in<em>min,in</em>max] to a value in [out<em>min,out</em>max]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/misc.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.log_likelihood!-Tuple{FelNode, Any}" href="#MolecularEvolution.log_likelihood!-Tuple{FelNode, Any}"><code>MolecularEvolution.log_likelihood!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_likelihood!(tree::FelNode, models; partition_list = nothing)</code></pre><p>First re-computes the upward felsenstein pass, and then computes the log likelihood of this tree. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/algorithms/lls.jl#L45-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.log_likelihood-Tuple{FelNode, BranchModel}" href="#MolecularEvolution.log_likelihood-Tuple{FelNode, BranchModel}"><code>MolecularEvolution.log_likelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_likelihood(tree::FelNode, models; partition_list = nothing)</code></pre><p>Computed the log likelihood of this tree. Requires felsenstein!() to have been run. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/algorithms/lls.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.longest_path-Tuple{FelNode}" href="#MolecularEvolution.longest_path-Tuple{FelNode}"><code>MolecularEvolution.longest_path</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the longest path in a tree For convenience, this is returned as two lists of form:     [leaf<em>node, parent</em>node, .... root] Where the leaf_node nodes are selected to be the furthest away</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/base_tree_utils.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.marginal_state_dict-Tuple{FelNode, Any}" href="#MolecularEvolution.marginal_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.marginal_state_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marginal_state_dict(tree::FelNode, model; partition_list = 1:length(tree.message), node_message_dict = Dict{FelNode,Vector{Partition}}())</code></pre><p>Takes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode-&gt;Array{&lt;:BranchModel}), and returns a dictionary mapping nodes to their marginal reconstructions (ie. P(state|all observations,model)). A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you&#39;re running this over and over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/algorithms/ancestors.jl#L111-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.matrix_for_display-Tuple{Any, Any}" href="#MolecularEvolution.matrix_for_display-Tuple{Any, Any}"><code>MolecularEvolution.matrix_for_display</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_for_display(Q,labels)</code></pre><p>Takes a numerical matrix and a vector of labels, and returns a typically mixed type matrix with the numerical values and the labels. This is to easily visualize rate matrices in eg. the REPL.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/models/discrete_models/utils/matrix_helpers.jl#L196-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.midpoint-Tuple{FelNode}" href="#MolecularEvolution.midpoint-Tuple{FelNode}"><code>MolecularEvolution.midpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a midpoint as a node and a distance above it where the midpoint is</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/base_tree_utils.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.mix-Union{Tuple{SWMPartition{PType}}, Tuple{PType}} where PType&lt;:DiscretePartition" href="#MolecularEvolution.mix-Union{Tuple{SWMPartition{PType}}, Tuple{PType}} where PType&lt;:DiscretePartition"><code>MolecularEvolution.mix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mix(swm_part::SWMPartition{PType} ) where {PType &lt;: MultiSitePartition}</code></pre><p><code>mix</code> collapses a Site-Wise Mixture partition to a single component partition, weighted by the site-wise likelihoods for each component, and the init weights. Specifically, it takes a <code>SWMPartition{Ptype}</code> and returns a <code>PType</code>. You&#39;ll need to have this implemented for certain helper functionality if you&#39;re playing with new kinds of SWMPartitions that aren&#39;t mixtures of <code>DiscretePartitions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/models/compound_models/swm.jl#L160-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.name2node_dict-Tuple{AbstractTreeNode}" href="#MolecularEvolution.name2node_dict-Tuple{AbstractTreeNode}"><code>MolecularEvolution.name2node_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><p>name2node_dict(root)</p><p>Returns a dictionary of leaf nodes, indexed by node.name. Can be used to associate sequences with leaf nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/AbstractTreeNode.jl#L495-L499">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.newick-Tuple{AbstractTreeNode}" href="#MolecularEvolution.newick-Tuple{AbstractTreeNode}"><code>MolecularEvolution.newick</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newick(root)</code></pre><p>Returns a newick string representation of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/AbstractTreeNode.jl#L581-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.nni_optim!-Tuple{FelNode, Any}" href="#MolecularEvolution.nni_optim!-Tuple{FelNode, Any}"><code>MolecularEvolution.nni_optim!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nni_optim!(tree::FelNode, models; partition_list = nothing, tol = 1e-5)</code></pre><p>Considers local branch swaps for all branches recursively, maintaining the integrity of the messages. Requires felsenstein!() to have been run first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition<em>list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over (but you probably want to optimize tree topology with all models). acc</em>rule allows you to specify a function that takes the current and proposed log likelihoods, and if true is returned the move is accepted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/algorithms/nni_optim.jl#L218-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.node_distances-Tuple{AbstractTreeNode}" href="#MolecularEvolution.node_distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.node_distances</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the distance to all other nodes from a given node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/base_tree_utils.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.nonreversibleQ-Tuple{Any}" href="#MolecularEvolution.nonreversibleQ-Tuple{Any}"><code>MolecularEvolution.nonreversibleQ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonreversibleQ(param_vec)</code></pre><p>Takes a vector of parameters and returns a nonreversible rate matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/models/discrete_models/utils/matrix_helpers.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.parent_list-Tuple{FelNode}" href="#MolecularEvolution.parent_list-Tuple{FelNode}"><code>MolecularEvolution.parent_list</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Provides a list of parent nodes nodes from this node up to the root node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/base_tree_utils.jl#L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.partition2obs-Tuple{DiscretePartition, String}" href="#MolecularEvolution.partition2obs-Tuple{DiscretePartition, String}"><code>MolecularEvolution.partition2obs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition2obs(part::Partition)</code></pre><p>Extracts the most likely state from a Partition, transforming it into a convenient type. For example, a NucleotidePartition will be transformed into a nucleotide sequence of type String. Note: You should overload this for your own Partititon types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/models/discrete_models/utils/seq_to_vec.jl#L70-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.populate_tree!-Tuple{FelNode, Partition, Any, Any}" href="#MolecularEvolution.populate_tree!-Tuple{FelNode, Partition, Any, Any}"><code>MolecularEvolution.populate_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">populate_tree!(tree::FelNode, starting_message, names, data; init_all_messages = true, tolerate_missing = 1)</code></pre><p>Takes a tree, and a <code>starting_message</code> (which will serve as the memory template for populating messages all over the tree). <code>starting_message</code> can be a message (ie. a vector of Partitions), but will also work with a single Partition (although the tree) will still be populated with a length-1 vector of Partitions. Further, as long as <code>obs2partition</code> is implemented for your Partition type, the leaf nodes will be populated with the data from <code>data</code>, matching the names on each leaf. When a leaf on the tree has a name that doesn&#39;t match anything in <code>names</code>, then if</p><ul><li><code>tolerate_missing = 0</code>, an error will be thrown</li><li><code>tolerate_missing = 1</code>, a warning will be thrown, and the message will be set to the uninformative message (requires identity!(::Partition) to be defined)</li><li><code>tolerate_missing = 2</code>, the message will be set to the uninformative message, without warnings (requires identity!(::Partition) to be defined)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/misc.jl#L109-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.promote_internal-Tuple{FelNode}" href="#MolecularEvolution.promote_internal-Tuple{FelNode}"><code>MolecularEvolution.promote_internal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">promote_internal(tree::FelNode)</code></pre><p>Creates a new tree similar to the given tree, but with &#39;dummy&#39; leaf nodes (w/ zero branchlength) representing each internal node (for drawing / evenly spacing labels internal nodes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/tree_compose.jl#L615-L620">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.quadratic_CI-Tuple{Function, Vector, Int64}" href="#MolecularEvolution.quadratic_CI-Tuple{Function, Vector, Int64}"><code>MolecularEvolution.quadratic_CI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quadratic_CI(f::Function,opt_params::Vector, param_ind::Int; rate_conf_level = 0.99, nudge_amount = 0.01)</code></pre><p>Takes a NEGATIVE log likelihood function (compatible with Optim.jl), a vector of maximizing parameters, an a parameter index. Returns the quadratic confidence interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/simple_optim.jl#L353-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.quadratic_CI-Tuple{Vector, Vector}" href="#MolecularEvolution.quadratic_CI-Tuple{Vector, Vector}"><code>MolecularEvolution.quadratic_CI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quadratic_CI(xvec,yvec; rate_conf_level = 0.99)</code></pre><p>Takes xvec, a vector of parameter values, and yvec, a vector of log likelihood evaluations (note: NOT the negative LLs you) might use with Optim.jl. Returns the confidence intervals computed by a quadratic approximation to the LL.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/simple_optim.jl#L329-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.read_fasta-Tuple{String}" href="#MolecularEvolution.read_fasta-Tuple{String}"><code>MolecularEvolution.read_fasta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_fasta(filepath::String)</code></pre><p>Reads in a fasta file and returns a tuple of (seqnames, seqs).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/fasta_io.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.read_newick_tree-Tuple{String}" href="#MolecularEvolution.read_newick_tree-Tuple{String}"><code>MolecularEvolution.read_newick_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>read<em>newick</em>tree(treefile)</p><p>Reads in a tree from a file, of type FelNode</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/misc.jl#L252-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.reversibleQ-Tuple{Any, Any}" href="#MolecularEvolution.reversibleQ-Tuple{Any, Any}"><code>MolecularEvolution.reversibleQ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reversibleQ(param_vec,eq_freqs)</code></pre><p>Takes a vector of parameters and equilibrium frequencies and returns a reversible rate matrix. The parameters are the upper triangle of the rate matrix, with the diagonal elements omitted, and the equilibrium frequencies are multiplied column-wise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/models/discrete_models/utils/matrix_helpers.jl#L122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.root2tip_distances-Tuple{AbstractTreeNode}" href="#MolecularEvolution.root2tip_distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.root2tip_distances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">root2tips(root::AbstractTreeNode)</code></pre><p>Returns a vector of root-to-tip distances, and a node-to-index dictionary. Be aware that this dictionary will break when any of the node content (ie. anything on the tree) changes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/AbstractTreeNode.jl#L728-L733">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.sample_down!-Tuple{FelNode, Any, Any}" href="#MolecularEvolution.sample_down!-Tuple{FelNode, Any, Any}"><code>MolecularEvolution.sample_down!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sample<em>down!(root::FelNode,models,partition</em>list)</p><p>Generates samples under the model. The root.parent<em>message is taken as the starting distribution, and node.message contains the sampled messages. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition</em>list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/algorithms/generative.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.sample_from_message!-Tuple{Vector{&lt;:Partition}}" href="#MolecularEvolution.sample_from_message!-Tuple{Vector{&lt;:Partition}}"><code>MolecularEvolution.sample_from_message!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_from_message!(message::Vector{&lt;:Partition})</code></pre><p>#Replaces an uncertain message with a sample from the distribution represented by each partition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/algorithms/generative.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.savefig_tweakSVG-Tuple{Any, Context}" href="#MolecularEvolution.savefig_tweakSVG-Tuple{Any, Context}"><code>MolecularEvolution.savefig_tweakSVG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">savefig_tweakSVG(fname, plot::Context; width = 10cm, height = 10cm, linecap_round = true, white_background = true)</code></pre><p>Saves a figure created using the <code>Compose</code> approach, but tweaks the SVG after export.</p><p>eg. <code>savefig_tweakSVG(&quot;export.svg&quot;,pl)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/tree_compose.jl#L1012-L1018">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.savefig_tweakSVG-Tuple{Any, Plots.Plot}" href="#MolecularEvolution.savefig_tweakSVG-Tuple{Any, Plots.Plot}"><code>MolecularEvolution.savefig_tweakSVG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">savefig_tweakSVG(fname, plot::Plots.Plot; hack_bounding_box = true, new_viewbox = nothing, linecap_round = true)</code></pre><p>Note: Might only work if you&#39;re using the GR backend!! Saves a figure created using the <code>Phylo</code> <code>Plots</code> recipe, but tweaks the SVG after export. <code>new_viewbox</code> needs to be an array of 4 numbers, typically starting at <code>[0 0 plot_width*4 plot_height*4]</code> but this lets you add shifts, in case the plot is getting cut off.</p><p>eg. <code>savefig_tweakSVG(&quot;export.svg&quot;,pl, new_viewbox = [-100, -100, 3000, 4500])</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/phylo_glue.jl#L83-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.shortest_path_between_nodes-Tuple{FelNode, FelNode}" href="#MolecularEvolution.shortest_path_between_nodes-Tuple{FelNode, FelNode}"><code>MolecularEvolution.shortest_path_between_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shortest path between nodes, returned as two lists, each starting with one of the two nodes,  and ending with the common ancestor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/base_tree_utils.jl#L84-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.sibling_inds-Tuple{AbstractTreeNode}" href="#MolecularEvolution.sibling_inds-Tuple{AbstractTreeNode}"><code>MolecularEvolution.sibling_inds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sibling_inds(node)</p><p>Returns logical indices of the siblings in the parent&#39;s child&#39;s vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/AbstractTreeNode.jl#L481-L485">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.siblings-Tuple{AbstractTreeNode}" href="#MolecularEvolution.siblings-Tuple{AbstractTreeNode}"><code>MolecularEvolution.siblings</code></a> — <span class="docstring-category">Method</span></header><section><div><p>siblings(node)</p><p>Returns a vector of siblings of node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/AbstractTreeNode.jl#L467-L471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.sim_tree-Tuple{Int64, Any, Any}" href="#MolecularEvolution.sim_tree-Tuple{Int64, Any, Any}"><code>MolecularEvolution.sim_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_tree(add_limit::Int,Ne_func,sample_rate_func; nstart = 1, time = 0.0, mutation_rate = 1.0, T = Float64)</code></pre><p>Simulates a tree of type FelNode{T}. Allows an effective population size function (Ne<em>func), as well as a sample rate function (sample</em>rate_func), which can also just be constants.</p><p>Ne<em>func(t) = (sin(t/10)+1)*100.0 + 10.0 root = sim</em>tree(600,Ne<em>func,1.0) simple</em>tree_draw(ladderize(root))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/sim_tree.jl#L94-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.sim_tree-Tuple{}" href="#MolecularEvolution.sim_tree-Tuple{}"><code>MolecularEvolution.sim_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_tree(;n = 10)</code></pre><p>Simulates tree with constant population size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/sim_tree.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.simple_radial_tree_plot-Tuple{FelNode}" href="#MolecularEvolution.simple_radial_tree_plot-Tuple{FelNode}"><code>MolecularEvolution.simple_radial_tree_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simple_radial_tree_plot(root::FelNode; canvas_width = 10cm, line_color = &quot;black&quot;, line_width = 0.1mm)</code></pre><p>Draws a radial tree. No frills. No labels. Canvas height is automatically determined to avoid distorting the tree.</p><p>newt = better<em>newick</em>import(&quot;((A:1,B:1,C:1,D:1,E:1,F:1,G:1):1,(H:1,I:1):1);&quot;, FelNode{Float64}); simple<em>radial</em>tree<em>plot(newt,line</em>width = 0.5mm,root_angle = 7/10)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/tree_compose.jl#L423-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.simple_tree_draw-Tuple{FelNode}" href="#MolecularEvolution.simple_tree_draw-Tuple{FelNode}"><code>MolecularEvolution.simple_tree_draw</code></a> — <span class="docstring-category">Method</span></header><section><div><p>img = simple<em>tree</em>draw(tree::FelNode; canvas<em>width = 15cm, canvas</em>height = 15cm, line<em>color = &quot;black&quot;, line</em>width = 0.1mm)</p><p>A line drawing of a tree with very few options.</p><pre><code class="language-julia hljs">img = simple_tree_draw(tree)
img |&gt; SVG(&quot;imgout.svg&quot;,10cm, 10cm)
OR
using Cairo
img |&gt; PDF(&quot;imgout.pdf&quot;,10cm, 10cm)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/tree_compose.jl#L92-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.total_LL-Tuple{Partition}" href="#MolecularEvolution.total_LL-Tuple{Partition}"><code>MolecularEvolution.total_LL</code></a> — <span class="docstring-category">Method</span></header><section><div><p>total_LL(p::Partition)</p><p>If called on the root, it returns the log likelihood associated with that partition. Can be overloaded for complex partitions without straightforward site log likelihoods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/algorithms/lls.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.tree2distances-Tuple{AbstractTreeNode}" href="#MolecularEvolution.tree2distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.tree2distances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tree2distances(root::AbstractTreeNode)</code></pre><p>Returns a distance matrix for all pairs of leaf nodes, and a node-to-index dictionary. Be aware that this dictionary will break when any of the node content (ie. anything on the tree) changes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/AbstractTreeNode.jl#L691-L696">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.tree2shared_branch_lengths-Tuple{AbstractTreeNode}" href="#MolecularEvolution.tree2shared_branch_lengths-Tuple{AbstractTreeNode}"><code>MolecularEvolution.tree2shared_branch_lengths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tree2distances(root::AbstractTreeNode)</code></pre><p>Returns a distance matrix for all pairs of leaf nodes, and a node-to-index dictionary. Be aware that this dictionary will break when any of the node content (ie. anything on the tree) changes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/core/nodes/AbstractTreeNode.jl#L746-L751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.tree_draw-Tuple{FelNode}" href="#MolecularEvolution.tree_draw-Tuple{FelNode}"><code>MolecularEvolution.tree_draw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tree_draw(tree::FelNode;
    canvas_width = 15cm, canvas_height = 15cm,
    stretch_for_labels = 2.0, draw_labels = true,
    line_width = 0.1mm, font_size = 4pt,
    min_dot_size = 0.00, max_dot_size = 0.01,
    line_opacity = 1.0,
    dot_opacity = 1.0,
    name_opacity = 1.0,
    horizontal = true,
    dot_size_dict = Dict(), dot_size_default = 0.0,
    dot_color_dict = Dict(), dot_color_default = &quot;black&quot;,
    line_color_dict = Dict(), line_color_default = &quot;black&quot;,
    label_color_dict = Dict(), label_color_default = &quot;black&quot;,
    nodelabel_dict = Dict(),compose_dict = Dict()
    )</code></pre><p>Draws a tree with a number of self-explanatory options. Dictionaries that map a node to a color/size are used to control per-node plotting options. <code>compose_dict</code> must be a <code>FelNode-&gt;function(x,y)</code> dictionary that returns a <code>compose()</code> struct.</p><p>Example using <code>compose_dict</code></p><pre><code class="language-julia hljs">str_tree = &quot;(((((tax24:0.09731668728575642,(tax22:0.08792233964843627,tax18:0.9210388482867483):0.3200367900275155):0.6948314526087965,(tax13:1.9977212308725611,(tax15:0.4290074347886068,(tax17:0.32928401808187824,(tax12:0.3860215462534818,tax16:0.2197134841232339):0.1399122681886174):0.05744611946245004):1.4686085778061146):0.20724159879522402):0.4539334554156126,tax28:0.4885576926440158):0.002162260013924424,tax26:0.9451873777301325):3.8695419798779387,((tax29:0.10062813251515536,tax27:0.27653633028085006):0.04262434258357507,(tax25:0.009345653929737636,((tax23:0.015832941547076644,(tax20:0.5550597590956172,((tax8:0.6649025646927402,tax9:0.358506423199849):0.1439516404012261,tax11:0.01995439013213013):1.155181296134081):0.17930021667907567):0.10906638146207207,((((((tax6:0.013708993438720255,tax5:0.061144001556547097):0.1395453591567641,tax3:0.4713722705245479):0.07432598428904214,tax1:0.5993347898257291):1.0588025698844894,(tax10:0.13109032492533992,(tax4:0.8517302241963356,(tax2:0.8481963081549965,tax7:0.23754095940676642):0.2394313086297733):0.43596704123297675):0.08774657269409454):0.9345533723114966,(tax14:0.7089558245245173,tax19:0.444897137240675):0.08657675809803095):0.01632062723968511,tax21:0.029535281963725537):0.49502691718938285):0.25829576024240986):0.7339777396780424):4.148878039524972):0.0&quot;
newt = gettreefromnewick(str_tree, FelNode)
ladderize!(newt)
compose_dict = Dict()
for n in getleaflist(newt)
    #Replace the rand(4) with the frequencies you actually want.
    compose_dict[n] = (x,y)-&gt;pie_chart(x,y,MolecularEvolution.sum2one(rand(4)),size = 0.03)
end
tree_draw(newt,draw_labels = false,line_width = 0.5mm, compose_dict = compose_dict)


img = tree_draw(tree)
img |&gt; SVG(&quot;imgout.svg&quot;,10cm, 10cm)
OR
using Cairo
img |&gt; PDF(&quot;imgout.pdf&quot;,10cm, 10cm)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/tree_compose.jl#L137-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.tree_polish!-Tuple{Any, Any}" href="#MolecularEvolution.tree_polish!-Tuple{Any, Any}"><code>MolecularEvolution.tree_polish!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>tree_polish!(newt, models; tol = 10^-4, verbose = 1, topology = true)</p><p>Takes a tree and a model function, and optimizes branch lengths and, optionally, topology. Returns final LL. Set <code>verbose=0</code> to suppress output. Note: This is not intended for an exhaustive tree search (which requires different heuristics), but rather to polish a tree that is already relatively close to the optimum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/misc.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.unc2probvec-Tuple{Any}" href="#MolecularEvolution.unc2probvec-Tuple{Any}"><code>MolecularEvolution.unc2probvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unc2probvec(v)</code></pre><p>Takes an array of N-1 unbounded values and returns an array of N values that sums to 1. Typically useful for optimizing over categorical probability distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/models/discrete_models/utils/matrix_helpers.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.univariate_maximize-Tuple{Any, Real, Real, Any, BrentsMethodOpt, Real}" href="#MolecularEvolution.univariate_maximize-Tuple{Any, Real, Real, Any, BrentsMethodOpt, Real}"><code>MolecularEvolution.univariate_maximize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">univariate_maximize(f, a::Real, b::Real, transform, optimizer::BrentsMethodOpt, t::Real; ε::Real=sqrt(eps))</code></pre><p>Maximizes <code>f(x)</code> using Brent&#39;s method. See <code>?brents_method_minimize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/simple_optim.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.univariate_maximize-Tuple{Any, Real, Real, Any, GoldenSectionOpt, Real}" href="#MolecularEvolution.univariate_maximize-Tuple{Any, Real, Real, Any, GoldenSectionOpt, Real}"><code>MolecularEvolution.univariate_maximize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">univariate_maximize(f, a::Real, b::Real, transform, optimizer::GoldenSectionOpt, tol::Real)</code></pre><p>Maximizes <code>f(x)</code> using a Golden Section Search. See <code>?golden_section_maximize</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = -(x-2)^2
f (generic function with 1 method)

julia&gt; m = univariate_maximize(f, 1, 5, identity, GoldenSectionOpt(), 1e-10)
2.0000000000051843</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/simple_optim.jl#L73-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.values_from_phylo_tree-Tuple{Any, Any}" href="#MolecularEvolution.values_from_phylo_tree-Tuple{Any, Any}"><code>MolecularEvolution.values_from_phylo_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">values_from_phylo_tree(phylo_tree, key)

Returns a list of values from the given key in the nodes of the phylo_tree, in an order that is somehow compatible with the order the nodes get plotted in.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/viz/phylo_glue.jl#L71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.weightEM-Tuple{Matrix{Float64}, Any}" href="#MolecularEvolution.weightEM-Tuple{Matrix{Float64}, Any}"><code>MolecularEvolution.weightEM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weightEM(con_lik_matrix::Array{Float64,2}, θ; conc = 0.0, iters = 500)</code></pre><p>Takes a conditional likelihood matrix (#categories-by-sites) and a starting frequency vector θ (length(θ) = #categories) and optimizes θ (using Expectation Maximization. Maybe.). If conc &gt; 0 then this gives something like variational bayes behavior for LDA. Maybe.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/misc.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.write_fasta-Tuple{String, Vector{String}}" href="#MolecularEvolution.write_fasta-Tuple{String, Vector{String}}"><code>MolecularEvolution.write_fasta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_fasta(filepath::String, sequences::Vector{String}; seq_names = nothing)</code></pre><p>Writes a fasta file from a vector of sequences, with optional seq_names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/fasta_io.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.write_nexus-Tuple{String, FelNode}" href="#MolecularEvolution.write_nexus-Tuple{String, FelNode}"><code>MolecularEvolution.write_nexus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_nexus(fname::String,tree::FelNode)</code></pre><p>Writes the tree as a nexus file, suitable for opening in eg. FigTree. Data in the <code>node_data</code> dictionary will be converted into annotations. Only tested for simple <code>node_data</code> formats and types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/6d25159c29b55ed59b79a205b5e2f6cbf9526f0c/src/utils/misc.jl#L280-L286">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="framework/">The MolecularEvolution.jl Framework »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 16 May 2024 12:53">Thursday 16 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
