<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MolecularEvolution.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://MurrellGroup.github.io/MolecularEvolution.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="MolecularEvolution.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>MolecularEvolution.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="quickstart/">Quick Start</a></li><li><a class="tocitem" href="types/">The MolecularEvolution.jl Framework</a></li><li><a class="tocitem" href="simulation/">Simulation</a></li><li><a class="tocitem" href="optimization/">Optimization</a></li><li><a class="tocitem" href="ancestors/">Ancestral Reconstruction</a></li><li><a class="tocitem" href="viz/">Visualization</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MolecularEvolution"><a class="docs-heading-anchor" href="#MolecularEvolution">MolecularEvolution</a><a id="MolecularEvolution-1"></a><a class="docs-heading-anchor-permalink" href="#MolecularEvolution" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/MurrellGroup/MolecularEvolution.jl">MolecularEvolution</a>.</p><h3 id="A-Julia-package-for-the-flexible-development-of-phylogenetic-models."><a class="docs-heading-anchor" href="#A-Julia-package-for-the-flexible-development-of-phylogenetic-models.">A Julia package for the flexible development of phylogenetic models.</a><a id="A-Julia-package-for-the-flexible-development-of-phylogenetic-models.-1"></a><a class="docs-heading-anchor-permalink" href="#A-Julia-package-for-the-flexible-development-of-phylogenetic-models." title="Permalink"></a></h3><p>MolecularEvolution.jl exploits Julia&#39;s multiple dispatch, implementing a fully generic suite of likelihood calculations, branchlength optimization, topology optimization, and ancestral inference. Users can construct trees using already-defined data types and models. But users can define probability distributions over their own data types, and specify the behavior of these under their own model types, and can mix and match different models on the same phylogeny.</p><h3 id="Authors:"><a class="docs-heading-anchor" href="#Authors:">Authors:</a><a id="Authors:-1"></a><a class="docs-heading-anchor-permalink" href="#Authors:" title="Permalink"></a></h3><p>Venkatesh Kumar and Ben Murrell, with additional contributions by Sanjay Mohan, Alec Pankow, and Kenta Sato.</p><h3 id="Quick-example:-Likelihood-calculations-under-phylogenetic-Brownian-motion:"><a class="docs-heading-anchor" href="#Quick-example:-Likelihood-calculations-under-phylogenetic-Brownian-motion:">Quick example: Likelihood calculations under phylogenetic Brownian motion:</a><a id="Quick-example:-Likelihood-calculations-under-phylogenetic-Brownian-motion:-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-example:-Likelihood-calculations-under-phylogenetic-Brownian-motion:" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MolecularEvolution, Plots

#First simulate a tree, using a coalescent process
tree = sim_tree(n=200)
internal_message_init!(tree, GaussianPartition())
#Simulate brownian motion over the tree
bm_model = BrownianMotion(0.0,1.0)
sample_down!(tree, bm_model)
#And plot the log likelihood as a function of the parameter value
ll(x) = log_likelihood!(tree,BrownianMotion(0.0,x))
plot(0.7:0.001:1.6,ll, xlabel = &quot;variance per unit time&quot;, ylabel = &quot;log likelihood&quot;)</code></pre><p><img src="figures/quick_example.svg" alt/></p><ul><li><a href="#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode"><code>Base.:==</code></a></li><li><a href="#MolecularEvolution._mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any, Any}} where T&lt;:Function"><code>MolecularEvolution._mapreduce</code></a></li><li><a href="#MolecularEvolution.bfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function"><code>MolecularEvolution.bfs_mapreduce</code></a></li><li><a href="#MolecularEvolution.branchlength_optim!-Tuple{FelNode, Any}"><code>MolecularEvolution.branchlength_optim!</code></a></li><li><a href="#MolecularEvolution.deepequals-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode"><code>MolecularEvolution.deepequals</code></a></li><li><a href="#MolecularEvolution.dfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function"><code>MolecularEvolution.dfs_mapreduce</code></a></li><li><a href="ancestors/#MolecularEvolution.endpoint_conditioned_sample_state_dict"><code>MolecularEvolution.endpoint_conditioned_sample_state_dict</code></a></li><li><a href="#MolecularEvolution.endpoint_conditioned_sample_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.endpoint_conditioned_sample_state_dict</code></a></li><li><a href="#MolecularEvolution.expected_subs_per_site-Tuple{Any, Any}"><code>MolecularEvolution.expected_subs_per_site</code></a></li><li><a href="#MolecularEvolution.felsenstein!-Tuple{FelNode, Any}"><code>MolecularEvolution.felsenstein!</code></a></li><li><a href="#MolecularEvolution.felsenstein_down!-Tuple{FelNode, Any}"><code>MolecularEvolution.felsenstein_down!</code></a></li><li><a href="#MolecularEvolution.golden_section_maximize-Tuple{Any, Real, Real, Any, Real}"><code>MolecularEvolution.golden_section_maximize</code></a></li><li><a href="#MolecularEvolution.internal_message_init!-Tuple{FelNode, Partition}"><code>MolecularEvolution.internal_message_init!</code></a></li><li><a href="#MolecularEvolution.internal_message_init!-Tuple{FelNode, Vector{&lt;:Partition}}"><code>MolecularEvolution.internal_message_init!</code></a></li><li><a href="#MolecularEvolution.istreeconsistent-Tuple{T} where T&lt;:AbstractTreeNode"><code>MolecularEvolution.istreeconsistent</code></a></li><li><a href="#MolecularEvolution.linear_scale-NTuple{5, Any}"><code>MolecularEvolution.linear_scale</code></a></li><li><a href="#MolecularEvolution.log_likelihood-Tuple{FelNode, BranchModel}"><code>MolecularEvolution.log_likelihood</code></a></li><li><a href="#MolecularEvolution.log_likelihood!-Tuple{FelNode, Any}"><code>MolecularEvolution.log_likelihood!</code></a></li><li><a href="#MolecularEvolution.longest_path-Tuple{FelNode}"><code>MolecularEvolution.longest_path</code></a></li><li><a href="ancestors/#MolecularEvolution.marginal_state_dict"><code>MolecularEvolution.marginal_state_dict</code></a></li><li><a href="#MolecularEvolution.marginal_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.marginal_state_dict</code></a></li><li><a href="ancestors/#MolecularEvolution.max_joint_state_dict"><code>MolecularEvolution.max_joint_state_dict</code></a></li><li><a href="#MolecularEvolution.max_joint_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.max_joint_state_dict</code></a></li><li><a href="#MolecularEvolution.midpoint-Tuple{FelNode}"><code>MolecularEvolution.midpoint</code></a></li><li><a href="#MolecularEvolution.name2node_dict-Tuple{AbstractTreeNode}"><code>MolecularEvolution.name2node_dict</code></a></li><li><a href="#MolecularEvolution.node_distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.node_distances</code></a></li><li><a href="#MolecularEvolution.parent_list-Tuple{FelNode}"><code>MolecularEvolution.parent_list</code></a></li><li><a href="#MolecularEvolution.quadratic_CI-Tuple{Vector, Vector}"><code>MolecularEvolution.quadratic_CI</code></a></li><li><a href="#MolecularEvolution.quadratic_CI-Tuple{Function, Vector, Int64}"><code>MolecularEvolution.quadratic_CI</code></a></li><li><a href="#MolecularEvolution.read_newick_tree-Tuple{String}"><code>MolecularEvolution.read_newick_tree</code></a></li><li><a href="#MolecularEvolution.root2tip_distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.root2tip_distances</code></a></li><li><a href="#MolecularEvolution.sample_down!-Tuple{FelNode, Any, Any}"><code>MolecularEvolution.sample_down!</code></a></li><li><a href="#MolecularEvolution.sample_from_message!-Tuple{Vector{&lt;:Partition}}"><code>MolecularEvolution.sample_from_message!</code></a></li><li><a href="#MolecularEvolution.shortest_path_between_nodes-Tuple{FelNode, FelNode}"><code>MolecularEvolution.shortest_path_between_nodes</code></a></li><li><a href="#MolecularEvolution.sibling_inds-Tuple{AbstractTreeNode}"><code>MolecularEvolution.sibling_inds</code></a></li><li><a href="#MolecularEvolution.siblings-Tuple{AbstractTreeNode}"><code>MolecularEvolution.siblings</code></a></li><li><a href="#MolecularEvolution.sim_tree-Tuple{}"><code>MolecularEvolution.sim_tree</code></a></li><li><a href="#MolecularEvolution.sim_tree-Tuple{Int64, Any, Any}"><code>MolecularEvolution.sim_tree</code></a></li><li><a href="#MolecularEvolution.simple_tree_opt!-Tuple{Any, Any}"><code>MolecularEvolution.simple_tree_opt!</code></a></li><li><a href="#MolecularEvolution.total_LL-Tuple{Partition}"><code>MolecularEvolution.total_LL</code></a></li><li><a href="#MolecularEvolution.tree2distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.tree2distances</code></a></li><li><a href="#MolecularEvolution.tree2shared_branch_lengths-Tuple{AbstractTreeNode}"><code>MolecularEvolution.tree2shared_branch_lengths</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode" href="#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(t1, t2)
Defaults to pointer equality</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/AbstractTreeNode.jl#L78-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution._mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any, Any}} where T&lt;:Function" href="#MolecularEvolution._mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any, Any}} where T&lt;:Function"><code>MolecularEvolution._mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Internal function. Helper for bfs<em>mapreduce and dfs</em>mapreduce</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/base_tree_utils.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.bfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function" href="#MolecularEvolution.bfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function"><code>MolecularEvolution.bfs_mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Performs a BFS map-reduce over the tree, starting at a given node For each node, map<em>reduce is called as:    map</em>reduce(curr<em>node::FelNode, prev</em>node::FelNode, aggregator) where prev_node is the previous node visited on the path from the start node to the current node It is expected to update the aggregator, and not return anything.</p><p>Not exactly conventional map-reduce, as map-reduce calls may rely on state in the aggregator added by map-reduce calls on other nodes visited earlier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/base_tree_utils.jl#L27-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.branchlength_optim!-Tuple{FelNode, Any}" href="#MolecularEvolution.branchlength_optim!-Tuple{FelNode, Any}"><code>MolecularEvolution.branchlength_optim!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">branchlength_optim!(tree::FelNode, models; partition_list = nothing, tol = 1e-5)</code></pre><p>Uses golden section search to optimize all branches recursively, maintaining the integrity of the messages. Requires felsenstein!() to have been run first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over (but you probably want to optimize branch lengths with all models). tol is the tolerance for the golden section search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/algorithms/branchlength_optim.jl#L90-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.deepequals-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode" href="#MolecularEvolution.deepequals-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractTreeNode"><code>MolecularEvolution.deepequals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deepequals(t1, t2)</code></pre><p>Checks whether two trees are equal by recursively calling this on all fields, except <code>:parent</code>, in order to prevent cycles. In order to ensure that the <code>:parent</code> field is not hiding something different on both trees, ensure that each is consistent first (see: <code>istreeconsistent</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/AbstractTreeNode.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.dfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function" href="#MolecularEvolution.dfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T&lt;:Function"><code>MolecularEvolution.dfs_mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Performs a DFS map-reduce over the tree, starting at a given node See bfs_mapreduce for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/base_tree_utils.jl#L46-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.endpoint_conditioned_sample_state_dict-Tuple{FelNode, Any}" href="#MolecularEvolution.endpoint_conditioned_sample_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.endpoint_conditioned_sample_state_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">endpoint_conditioned_sample_state_dict(tree::FelNode, model; partition_list = 1:length(tree.message), node_message_dict = Dict{FelNode,Vector{Partition}}())</code></pre><p>Takes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode-&gt;Array{&lt;:BranchModel}), and draws samples under the model conditions on the leaf observations. These samples are stored in the node<em>message</em>dict, which is returned. A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you&#39;re running this over and over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/algorithms/ancestors.jl#L200-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.expected_subs_per_site-Tuple{Any, Any}" href="#MolecularEvolution.expected_subs_per_site-Tuple{Any, Any}"><code>MolecularEvolution.expected_subs_per_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expected_subs_per_site(Q,mu)</code></pre><p>Takes a rate matrix Q and an equilibrium frequency vector, and calculates the expected number of substitutions per site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/utils/misc.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.felsenstein!-Tuple{FelNode, Any}" href="#MolecularEvolution.felsenstein!-Tuple{FelNode, Any}"><code>MolecularEvolution.felsenstein!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">felsenstein!(node::FelNode, models; partition_list = nothing)</code></pre><p>Should usually be called on the root of the tree. Propagates Felsenstein pass up from the tips to the root. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/algorithms/felsenstein.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.felsenstein_down!-Tuple{FelNode, Any}" href="#MolecularEvolution.felsenstein_down!-Tuple{FelNode, Any}"><code>MolecularEvolution.felsenstein_down!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">felsenstein_down!(node::FelNode, models; partition_list = 1:length(tree.message), temp_message = deepcopy(tree.message))</code></pre><p>Should usually be called on the root of the tree. Propagates Felsenstein pass down from the root to the tips. felsenstein!() should usually be called first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/algorithms/felsenstein.jl#L78-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.golden_section_maximize-Tuple{Any, Real, Real, Any, Real}" href="#MolecularEvolution.golden_section_maximize-Tuple{Any, Real, Real, Any, Real}"><code>MolecularEvolution.golden_section_maximize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Golden section search.</p><p>Given a function f with a single local minimum in the interval [a,b], gss returns a subset interval [c,d] that contains the minimum with d-c &lt;= tol.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = -(x-2)^2
f (generic function with 1 method)

julia&gt; m = golden_section_maximize(f, 1, 5, identity, 1e-10)
2.0000000000051843</code></pre><p>From: https://en.wikipedia.org/wiki/Golden-section_search</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/utils/simple_optim.jl#L15-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.internal_message_init!-Tuple{FelNode, Partition}" href="#MolecularEvolution.internal_message_init!-Tuple{FelNode, Partition}"><code>MolecularEvolution.internal_message_init!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">internal_message_init!(tree::FelNode, partition::Partition)

Initializes the message template for each node in the tree, as an array of the partition.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/FelNode.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.internal_message_init!-Tuple{FelNode, Vector{&lt;:Partition}}" href="#MolecularEvolution.internal_message_init!-Tuple{FelNode, Vector{&lt;:Partition}}"><code>MolecularEvolution.internal_message_init!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">internal_message_init!(tree::FelNode, empty_message::Vector{&lt;:Partition})

Initializes the message template for each node in the tree, allocating space for each partition.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/FelNode.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.istreeconsistent-Tuple{T} where T&lt;:AbstractTreeNode" href="#MolecularEvolution.istreeconsistent-Tuple{T} where T&lt;:AbstractTreeNode"><code>MolecularEvolution.istreeconsistent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">istreeconsistent(root)</code></pre><p>Checks whether the <code>:parent</code> field is set to be consistent with the <code>:child</code> field for all nodes in the subtree. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/AbstractTreeNode.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.linear_scale-NTuple{5, Any}" href="#MolecularEvolution.linear_scale-NTuple{5, Any}"><code>MolecularEvolution.linear_scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linear_scale(val,in_min,in_max,out_min,out_max)</code></pre><p>Linearly maps val which lives in [in<em>min,in</em>max] to a value in [out<em>min,out</em>max]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/utils/misc.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.log_likelihood!-Tuple{FelNode, Any}" href="#MolecularEvolution.log_likelihood!-Tuple{FelNode, Any}"><code>MolecularEvolution.log_likelihood!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_likelihood!(tree::FelNode, models; partition_list = nothing)</code></pre><p>First re-computes the upward felsenstein pass, and then computes the log likelihood of this tree. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/algorithms/lls.jl#L44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.log_likelihood-Tuple{FelNode, BranchModel}" href="#MolecularEvolution.log_likelihood-Tuple{FelNode, BranchModel}"><code>MolecularEvolution.log_likelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_likelihood(tree::FelNode, models; partition_list = nothing)</code></pre><p>Computed the log likelihood of this tree. Requires felsenstein!() to have been run. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/algorithms/lls.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.longest_path-Tuple{FelNode}" href="#MolecularEvolution.longest_path-Tuple{FelNode}"><code>MolecularEvolution.longest_path</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the longest path in a tree For convenience, this is returned as two lists of form:     [leaf<em>node, parent</em>node, .... root] Where the leaf_node nodes are selected to be the furthest away</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/base_tree_utils.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.marginal_state_dict-Tuple{FelNode, Any}" href="#MolecularEvolution.marginal_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.marginal_state_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marginal_state_dict(tree::FelNode, model; partition_list = 1:length(tree.message), node_message_dict = Dict{FelNode,Vector{Partition}}())</code></pre><p>Takes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode-&gt;Array{&lt;:BranchModel}), and returns a dictionary mapping nodes to their marginal reconstructions (ie. P(state|all observations,model)). A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you&#39;re running this over and over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/algorithms/ancestors.jl#L111-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.max_joint_state_dict-Tuple{FelNode, Any}" href="#MolecularEvolution.max_joint_state_dict-Tuple{FelNode, Any}"><code>MolecularEvolution.max_joint_state_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max_joint_state_dict(tree::FelNode, model; partition_list = 1:length(tree.message), node_message_dict = Dict{FelNode,Vector{Partition}}())</code></pre><p>Takes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode-&gt;Array{&lt;:BranchModel}), and returns a dictionary mapping nodes to their joint maximum likelihood reconstructions (ie. state, such that P(state|all observations,model) is maximized). A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you&#39;re running this over and over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/algorithms/ancestors.jl#L168-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.midpoint-Tuple{FelNode}" href="#MolecularEvolution.midpoint-Tuple{FelNode}"><code>MolecularEvolution.midpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a midpoint as a node and a distance above it where the midpoint is</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/base_tree_utils.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.name2node_dict-Tuple{AbstractTreeNode}" href="#MolecularEvolution.name2node_dict-Tuple{AbstractTreeNode}"><code>MolecularEvolution.name2node_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><p>name2node_dict(root)</p><p>Returns a dictionary of leaf nodes, indexed by node.name. Can be used to associate sequences with leaf nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/AbstractTreeNode.jl#L495-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.node_distances-Tuple{AbstractTreeNode}" href="#MolecularEvolution.node_distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.node_distances</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the distance to all other nodes from a given node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/base_tree_utils.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.parent_list-Tuple{FelNode}" href="#MolecularEvolution.parent_list-Tuple{FelNode}"><code>MolecularEvolution.parent_list</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Provides a list of parent nodes nodes from this node up to the root node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/base_tree_utils.jl#L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.quadratic_CI-Tuple{Function, Vector, Int64}" href="#MolecularEvolution.quadratic_CI-Tuple{Function, Vector, Int64}"><code>MolecularEvolution.quadratic_CI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quadratic_CI(f::Function,opt_params::Vector, param_ind::Int; rate_conf_level = 0.99, nudge_amount = 0.01)</code></pre><p>Takes a NEGATIVE log likelihood function (compatible with Optim.jl), a vector of maximizing parameters, an a parameter index. Returns the quadratic confidence interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/utils/simple_optim.jl#L220-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.quadratic_CI-Tuple{Vector, Vector}" href="#MolecularEvolution.quadratic_CI-Tuple{Vector, Vector}"><code>MolecularEvolution.quadratic_CI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quadratic_CI(xvec,yvec; rate_conf_level = 0.99)</code></pre><p>Takes xvec, a vector of parameter values, and yvec, a vector of log likelihood evaluations (note: NOT the negative LLs you) might use with Optim.jl. Returns the confidence intervals computed by a quadratic approximation to the LL.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/utils/simple_optim.jl#L196-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.read_newick_tree-Tuple{String}" href="#MolecularEvolution.read_newick_tree-Tuple{String}"><code>MolecularEvolution.read_newick_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>read<em>newick</em>tree(treefile)</p><p>Reads in a tree from a file, of type FelNode</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/utils/misc.jl#L249-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.root2tip_distances-Tuple{AbstractTreeNode}" href="#MolecularEvolution.root2tip_distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.root2tip_distances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">root2tips(root::AbstractTreeNode)</code></pre><p>Returns a vector of root-to-tip distances, and a node-to-index dictionary. Be aware that this dictionary will break when any of the node content (ie. anything on the tree) changes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/AbstractTreeNode.jl#L723-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.sample_down!-Tuple{FelNode, Any, Any}" href="#MolecularEvolution.sample_down!-Tuple{FelNode, Any, Any}"><code>MolecularEvolution.sample_down!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sample<em>down!(root::FelNode,models,partition</em>list)</p><p>Generates samples under the model. The root.parent<em>message is taken as the starting distribution, and node.message contains the sampled messages. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition</em>list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/algorithms/generative.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.sample_from_message!-Tuple{Vector{&lt;:Partition}}" href="#MolecularEvolution.sample_from_message!-Tuple{Vector{&lt;:Partition}}"><code>MolecularEvolution.sample_from_message!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_from_message!(message::Vector{&lt;:Partition})</code></pre><p>#Replaces an uncertain message with a sample from the distribution represented by each partition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/algorithms/generative.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.shortest_path_between_nodes-Tuple{FelNode, FelNode}" href="#MolecularEvolution.shortest_path_between_nodes-Tuple{FelNode, FelNode}"><code>MolecularEvolution.shortest_path_between_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shortest path between nodes, returned as two lists, each starting with one of the two nodes,  and ending with the common ancestor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/base_tree_utils.jl#L84-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.sibling_inds-Tuple{AbstractTreeNode}" href="#MolecularEvolution.sibling_inds-Tuple{AbstractTreeNode}"><code>MolecularEvolution.sibling_inds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sibling_inds(node)</p><p>Returns logical indices of the siblings in the parent&#39;s child&#39;s vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/AbstractTreeNode.jl#L481-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.siblings-Tuple{AbstractTreeNode}" href="#MolecularEvolution.siblings-Tuple{AbstractTreeNode}"><code>MolecularEvolution.siblings</code></a> — <span class="docstring-category">Method</span></header><section><div><p>siblings(node)</p><p>Returns a vector of siblings of node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/AbstractTreeNode.jl#L467-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.sim_tree-Tuple{Int64, Any, Any}" href="#MolecularEvolution.sim_tree-Tuple{Int64, Any, Any}"><code>MolecularEvolution.sim_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_tree(add_limit::Int,Ne_func,sample_rate_func; nstart = 1, time = 0.0, mutation_rate = 1.0, T = Float64)</code></pre><p>Simulates a tree of type FelNode{T}. Allows an effective population size function (Ne<em>func), as well as a sample rate function (sample</em>rate_func), which can also just be constants.</p><p>Ne<em>func(t) = (sin(t/10)+1)*100.0 + 10.0 root = sim</em>tree(600,Ne<em>func,1.0) simple</em>tree_draw(ladderize(root))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/sim_tree.jl#L94-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.sim_tree-Tuple{}" href="#MolecularEvolution.sim_tree-Tuple{}"><code>MolecularEvolution.sim_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_tree(;n = 10)</code></pre><p>Simulates tree with constant population size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/sim_tree.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.simple_tree_opt!-Tuple{Any, Any}" href="#MolecularEvolution.simple_tree_opt!-Tuple{Any, Any}"><code>MolecularEvolution.simple_tree_opt!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simple_tree_opt!(newt,models; tol = 10^-4, verbose = 0, topology = true)</code></pre><p>Takes a tree and a model function, and optimizes branch lengths and, optionally, topology.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/utils/misc.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.total_LL-Tuple{Partition}" href="#MolecularEvolution.total_LL-Tuple{Partition}"><code>MolecularEvolution.total_LL</code></a> — <span class="docstring-category">Method</span></header><section><div><p>total_LL(p::Partition)</p><p>If called on the root, it returns the log likelihood associated with that partition. Can be overloaded for complex partitions without straightforward site log likelihoods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/algorithms/lls.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.tree2distances-Tuple{AbstractTreeNode}" href="#MolecularEvolution.tree2distances-Tuple{AbstractTreeNode}"><code>MolecularEvolution.tree2distances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tree2distances(root::AbstractTreeNode)</code></pre><p>Returns a distance matrix for all pairs of leaf nodes, and a node-to-index dictionary. Be aware that this dictionary will break when any of the node content (ie. anything on the tree) changes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/AbstractTreeNode.jl#L686-L691">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.tree2shared_branch_lengths-Tuple{AbstractTreeNode}" href="#MolecularEvolution.tree2shared_branch_lengths-Tuple{AbstractTreeNode}"><code>MolecularEvolution.tree2shared_branch_lengths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tree2distances(root::AbstractTreeNode)</code></pre><p>Returns a distance matrix for all pairs of leaf nodes, and a node-to-index dictionary. Be aware that this dictionary will break when any of the node content (ie. anything on the tree) changes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/3cc6ba6d536272fcc893fd75f64effac798a99ef/src/core/nodes/AbstractTreeNode.jl#L741-L746">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="quickstart/">Quick Start »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 8 September 2022 23:54">Thursday 8 September 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
