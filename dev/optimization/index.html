<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimization · MolecularEvolution.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://MurrellGroup.github.io/MolecularEvolution.jl/optimization/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MolecularEvolution.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MolecularEvolution.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../framework/">The MolecularEvolution.jl Framework</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../IO/">Input/Output</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../simulation/">Simulation</a></li><li class="is-active"><a class="tocitem" href>Optimization</a><ul class="internal"><li><a class="tocitem" href="#Optimizing-model-parameters"><span>Optimizing model parameters</span></a></li><li><a class="tocitem" href="#Optimizing-the-tree-topology-and-branch-lengths"><span>Optimizing the tree topology and branch lengths</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li><li><a class="tocitem" href="../ancestors/">Ancestral Reconstruction</a></li><li><a class="tocitem" href="../viz/">Visualization</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Optimization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/main/docs/src/optimization.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimization"><a class="docs-heading-anchor" href="#Optimization">Optimization</a><a id="Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization" title="Permalink"></a></h1><p>There are two distinct kinds of optimization: &quot;global&quot; model parameters, and then tree branchlengths and topology. These are kept distinct because we can use algorithmic tricks to dramatically improve the performance of the latter.</p><p>The example below will set up and optimize a <a href="https://en.wikipedia.org/wiki/Substitution_model">&quot;Generalized Time Reversible&quot; nucleotide substitution model</a>, where there are 6 rate parameters that govern the symmetric part of a rate matrix, and 4 nucleotide frequencies (that sum to 1, so only 3 underlying parameters).</p><h2 id="Optimizing-model-parameters"><a class="docs-heading-anchor" href="#Optimizing-model-parameters">Optimizing model parameters</a><a id="Optimizing-model-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-model-parameters" title="Permalink"></a></h2><p>We first need to construct an objective function. A very common use case involves parameterizing a rate matrix (along with all the constraints this entails) from a flat parameter vector. <code>reversibleQ</code> can be convenient here, which takes a vector of parameters and equilibrium frequencies and returns a reversible rate matrix. The parameters are the upper triangle (excluding the diagonal) of the rate matrix:</p><pre><code class="language-julia hljs">reversibleQ(1:6,ones(4))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 Matrix{Float64}:
 -6.0    1.0    2.0    3.0
  1.0  -10.0    4.0    5.0
  2.0    4.0  -12.0    6.0
  3.0    5.0    6.0  -14.0</code></pre><p>...and the equilibrium frequencies are multiplied column-wise:</p><pre><code class="language-julia hljs">reversibleQ(ones(6),[0.1,0.2,0.3,0.4])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 Matrix{Float64}:
 -0.9   0.2   0.3   0.4
  0.1  -0.8   0.3   0.4
  0.1   0.2  -0.7   0.4
  0.1   0.2   0.3  -0.6</code></pre><p>Another convenient trick is to be able to parameterize a vector of positive frequencies that sum to 1, using N-1 unconstrained parameters. <code>unc2probvec</code> can help:</p><pre><code class="language-julia hljs">unc2probvec(zeros(3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
 0.25
 0.25
 0.25
 0.25</code></pre><p><a href="https://github.com/invenia/ParameterHandling.jl"><code>ParameterHandling.jl</code></a> provides a convenient framework for managing collections of parameters in a way that plays with much of the Julia optimization ecosystem, and we recommend its use. Here we&#39;ll use <code>ParameterHandling</code> and <a href="https://github.com/JuliaOpt/NLopt.jl"><code>NLopt</code></a>.</p><p>First, we&#39;ll load in some example nucleotide data:</p><pre><code class="language-julia hljs">using MolecularEvolution, FASTX, ParameterHandling, NLopt

#Read in seqs and tree, and populate the three  NucleotidePartitions
seqnames, seqs = read_fasta(&quot;Data/MusNuc_IGHV.fasta&quot;)
tree = read_newick_tree(&quot;Data/MusNuc_IGHV.tre&quot;)
initial_partition = NucleotidePartition(length(seqs[1]))
populate_tree!(tree,initial_partition,seqnames,seqs)</code></pre><p>Then we set up the model parameters, and the objective function:</p><pre><code class="language-julia hljs">#Named tuple of parameters, with initial values and constraints (from ParameterHandling.jl)
initial_params = (
        rates=positive(ones(6)), #rates must be non-negative
        pi=zeros(3) #will be transformed into 4 eq freqs
)
flat_initial_params, unflatten = value_flatten(initial_params) #See ParameterHandling.jl docs
num_params = length(flat_initial_params)

#Set up a function that builds a model from these parameters
function build_model_vec(params)
    pi = unc2probvec(params.pi)
    return DiagonalizedCTMC(reversibleQ(params.rates,pi))
end

#Set up the function to be *minimized*
function objective(params::NamedTuple; tree = tree)
    #In this example, we are optimizing the nuc equilibrium freqs
    #We&#39;ll also assume that the starting frequencies (at the root of the tree) are the eq freqs
    tree.parent_message[1].state .= unc2probvec(params.pi)
    return -log_likelihood!(tree,build_model_vec(params)) #Note, negative of LL, because minimization
end</code></pre><p>Then we&#39;ll set up an optimizer from <code>NLOpt</code>. See <a href="https://discourse.julialang.org/t/optim-what-optimiser-is-best-if-your-gradient-computation-is-slow/5487/12">this discussion</a> and <a href="https://github.com/SciML/DiffEqParamEstim.jl/blob/master/test/lorenz_true_test.jl">this exploration</a> of optimizers.</p><pre><code class="language-julia hljs">opt = Opt(:LN_BOBYQA, num_params)
#Note: NLopt requires a function that returns a gradient, even for gradient free methods, hence (x,y)-&gt;...
min_objective!(opt, (x,y) -&gt; (objective ∘ unflatten)(x)) #See ParameterHandling.jl docs for objective ∘ unflatten explanation
#Some bounds (which will be in the transformed domain) to prevent searching numerically silly bits of parameter space:
lower_bounds!(opt, [-10.0 for i in 1:num_params])
upper_bounds!(opt, [10.0 for i in 1:num_params])
xtol_rel!(opt, 1e-12)
_,mini,_ = NLopt.optimize(opt, flat_initial_params)
final_params = unflatten(mini)

optimized_model = build_model_vec(final_params)
println(&quot;Opt LL:&quot;,log_likelihood!(tree,optimized_model))</code></pre><pre><code class="nohighlight hljs">Opt LL:-3783.226756522292</code></pre><p>We can view the optimized parameter values:</p><pre><code class="nohighlight hljs">println(&quot;Rates: &quot;, round.(final_params.rates,sigdigits = 4))
println(&quot;Pi:&quot;, round.(unc2probvec(final_params.pi),sigdigits = 4))</code></pre><pre><code class="nohighlight hljs">Rates: [1.124, 2.102, 1.075, 0.9802, 1.605, 0.5536]
Pi:[0.2796, 0.2192, 0.235, 0.2662]</code></pre><p>Or the entire optimized rate matrix:</p><pre><code class="language-julia hljs">matrix_for_display(optimized_model.Q,[&#39;A&#39;,&#39;C&#39;,&#39;G&#39;,&#39;T&#39;])</code></pre><pre><code class="nohighlight hljs">Opt LL:-3783.226756522292
5×5 Matrix{Any}:
 &quot;&quot;     &#39;A&#39;        &#39;C&#39;        &#39;G&#39;        &#39;T&#39;
 &#39;A&#39;  -1.02672    0.246386   0.494024   0.286309
 &#39;C&#39;   0.314289  -0.971998   0.23034    0.427368
 &#39;G&#39;   0.587774   0.214842  -0.950007   0.147391
 &#39;T&#39;   0.300663   0.35183    0.130093  -0.782586</code></pre><h2 id="Optimizing-the-tree-topology-and-branch-lengths"><a class="docs-heading-anchor" href="#Optimizing-the-tree-topology-and-branch-lengths">Optimizing the tree topology and branch lengths</a><a id="Optimizing-the-tree-topology-and-branch-lengths-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-the-tree-topology-and-branch-lengths" title="Permalink"></a></h2><p>With a tree and a model, we can also optimize the branch lengths and search, by <a href="https://en.wikipedia.org/wiki/Tree_rearrangement">nearest neighbour interchange</a> for changes to the tree that improve the likelihood. Individually, these are performed by <code>nni_optim!</code> and <code>branchlength_optim!</code>, which need to have <code>felsenstein!</code> and <code>felsenstein_down!</code> called beforehand, but this is all bundled into:</p><pre><code class="language-julia hljs">tree_polish!(tree, optimized_model)</code></pre><pre><code class="nohighlight hljs">LL: -3783.226756522292
LL: -3782.345818028071
LL: -3782.3231632207567
LL: -3782.3211724011044
LL: -3782.321068684831
LL: -3782.3210622627776</code></pre><p>And just to convince you this works, we can perturb the branch lengths, and see how the likelihood improves:</p><pre><code class="language-julia hljs">for n in getnodelist(tree)
    n.branchlength *= (rand()+0.5)
end
tree_polish!(tree, optimzed_model)</code></pre><pre><code class="nohighlight hljs">LL: -3805.4140940138795
LL: -3782.884883999107
LL: -3782.351780962518
LL: -3782.322906364547
LL: -3782.321183009534
LL: -3782.3210398963506
LL: -3782.3210271696703</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>tree_polish!</code> probably won&#39;t find a good tree from a completely start. Different tree search heuristics are required for that.</p></div></div><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.reversibleQ" href="#MolecularEvolution.reversibleQ"><code>MolecularEvolution.reversibleQ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reversibleQ(param_vec,eq_freqs)</code></pre><p>Takes a vector of parameters and equilibrium frequencies and returns a reversible rate matrix. The parameters are the upper triangle of the rate matrix, with the diagonal elements omitted, and the equilibrium frequencies are multiplied column-wise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/70f696b17e4bbe9f1c232d55088c1ef208414c3e/src/models/discrete_models/utils/matrix_helpers.jl#L122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.unc2probvec" href="#MolecularEvolution.unc2probvec"><code>MolecularEvolution.unc2probvec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unc2probvec(v)</code></pre><p>Takes an array of N-1 unbounded values and returns an array of N values that sums to 1. Typically useful for optimizing over categorical probability distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/70f696b17e4bbe9f1c232d55088c1ef208414c3e/src/models/discrete_models/utils/matrix_helpers.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.branchlength_optim!" href="#MolecularEvolution.branchlength_optim!"><code>MolecularEvolution.branchlength_optim!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">branchlength_optim!(tree::FelNode, models; partition_list = nothing, tol = 1e-5)</code></pre><p>Uses golden section search to optimize all branches recursively, maintaining the integrity of the messages. Requires felsenstein!() to have been run first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over (but you probably want to optimize branch lengths with all models). tol is the tolerance for the golden section search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/70f696b17e4bbe9f1c232d55088c1ef208414c3e/src/core/algorithms/branchlength_optim.jl#L90-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.nni_optim!" href="#MolecularEvolution.nni_optim!"><code>MolecularEvolution.nni_optim!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nni_optim!(tree::FelNode, models; partition_list = nothing, tol = 1e-5)</code></pre><p>Uses golden section search to optimize all branches recursively, maintaining the integrity of the messages. Requires felsenstein!() to have been run first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition<em>list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over (but you probably want to optimize tree topology with all models). acc</em>rule allows you to specify a function that takes the current and proposed log likelihoods, and if true is returned the move is accepted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/70f696b17e4bbe9f1c232d55088c1ef208414c3e/src/core/algorithms/nni_optim.jl#L218-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.tree_polish!" href="#MolecularEvolution.tree_polish!"><code>MolecularEvolution.tree_polish!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>tree_polish!(newt, models; tol = 10^-4, verbose = 1, topology = true)</p><p>Takes a tree and a model function, and optimizes branch lengths and, optionally, topology. Returns final LL. Set <code>verbose=0</code> to suppress output. Note: This is not intended for an exhaustive tree search (which requires different heuristics), but rather to polish a tree that is already relatively close to the optimum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/70f696b17e4bbe9f1c232d55088c1ef208414c3e/src/utils/misc.jl#L135-L140">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simulation/">« Simulation</a><a class="docs-footer-nextpage" href="../ancestors/">Ancestral Reconstruction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 11 September 2022 16:29">Sunday 11 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
