<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simulation · MolecularEvolution.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://MurrellGroup.github.io/MolecularEvolution.jl/simulation/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MolecularEvolution.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MolecularEvolution.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../framework/">The MolecularEvolution.jl Framework</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../models/">Models</a></li><li class="is-active"><a class="tocitem" href>Simulation</a><ul class="internal"><li><a class="tocitem" href="#Simulating-phylogenies"><span>Simulating phylogenies</span></a></li><li><a class="tocitem" href="#Simulating-evolution-over-phylogenies"><span>Simulating evolution over phylogenies</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li><li><a class="tocitem" href="../optimization/">Optimization</a></li><li><a class="tocitem" href="../ancestors/">Ancestral Reconstruction</a></li><li><a class="tocitem" href="../viz/">Visualization</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Simulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/main/docs/src/simulation.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h1><p>The two key steps in phylogenetic simulation are 1) simulating the phylogeny itself, and 2) simulating data that evolves over the phylogeny.</p><h2 id="Simulating-phylogenies"><a class="docs-heading-anchor" href="#Simulating-phylogenies">Simulating phylogenies</a><a id="Simulating-phylogenies-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-phylogenies" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>While our <code>sim_tree</code> function seems to produce trees with the right shape, and is good enough for eg. generating varied tree shapes to evaluate different phylogeny inference schemes under, it is not yet sufficiently checked and tested for use where the details of the coalescent need to be absolutely accurate. It could, for example, be off by a constant factor somewhere. So if you plan on using this in a such a manner for a publication, please check the <code>sim_tree</code> code (and let us know).</p></div></div><p>If you just need a simple tree for testing things, then you can just use:</p><pre><code class="language-julia hljs">tree = sim_tree(n=100)
tree_draw(tree, draw_labels = false, canvas_height = 5cm)</code></pre><p><img src="../figures/constant_pop_simple.svg" alt/></p><p>This has the characteristic &quot;coalescent under constant population size&quot; look.</p><p>However, <code>sim_tree</code> is a bit more powerful than this: it aims to simulate branching under a coalescent process with flexible options for how the effective population size, as well as the sampling rate, might change over time. This is important, because the &quot;constant population size&quot; model is quite extreme, and most of the divergence happens in the early internal branches.</p><p>A coalescent process runs backwards in time, starting from the most recent tip, and sampling backwards toward the root, coalescing nodes as it goes, and sometimes adding additional sampled tips. With <code>sim_tree</code>, if <code>nstart = add_limit</code>, then all the tips will be sampled at the same time, and the tree will be ultrametric.</p><p><code>sim_tree</code> has two arguments driving its flexibility. We&#39;ll start with <code>sampling_rate</code>, which controls the rate at which samples are added to the tree. Even under constant effective population size, this can produce interesting behavior.</p><pre><code class="language-julia hljs">for sampling_rate in [5.0, 0.5, 0.05, 0.005]
    tree = sim_tree(100,1000.0,sampling_rate)
    display(tree_draw(tree, draw_labels = false, canvas_height = 5cm))
end</code></pre><p><img src="../figures/constant_Ne_samp_rate_5.0.svg" alt/></p><p><img src="../figures/constant_Ne_samp_rate_0.5.svg" alt/></p><p><img src="../figures/constant_Ne_samp_rate_0.05.svg" alt/></p><p><img src="../figures/constant_Ne_samp_rate_0.005.svg" alt/></p><p>Above, this rate was just a fixed constant value, but we can also let this be a function. In this example, we&#39;ll plot the tree alongside the sampling rate function, as well as the cumulative number of samples through time.</p><pre><code class="language-julia hljs">s(t) = ifelse(0&lt;mod(t/10,10)&lt;1,10.0,0.0)
tree = sim_tree(500,500.0,s)
display(tree_draw(tree, draw_labels = false, canvas_height = 5cm, canvas_width = 14cm))

#Figure out how tall the tree is
root_dists,_ = MolecularEvolution.root2tip_distances(tree)
mrd = maximum(root_dists)
sample_times = mrd .- root_dists
xvals = 0.0:0.1:mrd
display(plot(xvals,s, xflip = true, size = (500,250), xlabel = &quot;time&quot;,ylabel = &quot;sampling rate&quot;, legend = :none))
display(plot(xvals,x -&gt; sum(x .&gt; sample_times), xflip = true, size = (500,250), xlabel = &quot;time&quot;,ylabel = &quot;cumulative samples&quot;, legend = :none))</code></pre><p><img src="../figures/stepwise_sampling_tree.svg" alt/></p><p><img src="../figures/stepwise_sampling_sampling_rate.svg" alt/></p><p><img src="../figures/stepwise_sampling_cum_samps.svg" alt/></p><p>Note how the x axis of these plots is flipped, since the leaf furtherest from the root begins at time=0, and the coalescent runs backwards, from tip to root.</p><p>We can also vary the effective population size over time, which adds a different dimension of control. Here is an example showing the shape of a tree under exponential growth:</p><pre><code class="language-julia hljs">n(t) = 100000*exp(-t/10)
tree = sim_tree(100,n,100.0, nstart = 100)
display(tree_draw(tree, draw_labels = false, canvas_height = 7cm, canvas_width = 14cm))

root_dists,_ = MolecularEvolution.root2tip_distances(tree)
plot(0.0:0.1:maximum(root_dists),n, xflip = true, size = (500,250), xlabel = &quot;time&quot;,ylabel = &quot;effective population size&quot;, legend = :none)</code></pre><p><img src="../figures/exp_growth_tree.svg" alt/></p><p><img src="../figures/exp_growth_popsize.svg" alt/></p><p>Logistic growth, with a relatively low sampling rate, provides a reasonable model of an emerging virus that was only sampled later in its growth trajectory, such as HIV.</p><pre><code class="language-julia hljs">n(t) = 10000/(1+exp(t-10))
tree = sim_tree(100,n,20.0)
display(tree_draw(tree, draw_labels = false, canvas_height = 7cm, canvas_width = 14cm))

root_dists,_ = MolecularEvolution.root2tip_distances(tree)
display(plot(0.0:0.1:maximum(root_dists),n, xflip = true, size = (500,250), xlabel = &quot;time&quot;,ylabel = &quot;effective population size&quot;, legend = :none))

mrd = maximum(root_dists)
sample_times = mrd .- root_dists
plot(0.0:0.1:mrd,x -&gt; sum(x .&gt; sample_times), xflip = true, size = (500,250), xlabel = &quot;time&quot;,ylabel = &quot;cumulative samples&quot;, legend = :none)</code></pre><p><img src="../figures/logistic_growth_tree.svg" alt/></p><p><img src="../figures/logistic_growth_popsize.svg" alt/></p><p><img src="../figures/logistic_growth_cum_samps.svg" alt/></p><p>How about a virus with a seasonally varying effective population size, where sampling is proportional to case counts? Between seasons, the effective population size gets so low that the next seasons clade arises from a one or two lineages in the previous season.</p><pre><code class="language-julia hljs">n(t) = exp(sin(t/10) * 2.0 + 4)
s(t) = n(t)/100
tree = sim_tree(500,n,s)
display(tree_draw(tree, draw_labels = false))


root_dists,_ = MolecularEvolution.root2tip_distances(tree)
display(plot(0.0:0.1:maximum(root_dists),n, xflip = true, size = (500,250), xlabel = &quot;time&quot;,ylabel = &quot;effective population size&quot;, legend = :none))

mrd = maximum(root_dists)
sample_times = mrd .- root_dists
plot(0.0:0.1:mrd,x -&gt; sum(x .&gt; sample_times), xflip = true, size = (500,250), xlabel = &quot;time&quot;,ylabel = &quot;cumulative samples&quot;, legend = :none)</code></pre><p><img src="../figures/seasonal_tree.svg" alt/></p><p><img src="../figures/seasonal_popsize.svg" alt/></p><p><img src="../figures/seasonal_cum_samps.svg" alt/></p><p>Finally, the <code>mutation_rate</code> argument multiplicatively scales the branch lengths.</p><h2 id="Simulating-evolution-over-phylogenies"><a class="docs-heading-anchor" href="#Simulating-evolution-over-phylogenies">Simulating evolution over phylogenies</a><a id="Simulating-evolution-over-phylogenies-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-evolution-over-phylogenies" title="Permalink"></a></h2><p>We&#39;ll begin by simulating a tree, like the last example:</p><pre><code class="language-julia hljs">using MolecularEvolution, FASTX, Phylo, Plots, CSV, DataFrames

n(t) = exp(sin(t/10) * 2.0 + 4)
s(t) = n(t)/100
tree = sim_tree(500,n,s, mutation_rate = 0.005)</code></pre><p>If we need to open this tree in an external program, we can extract the Newick string representing this tree, and write it to a file:</p><pre><code class="language-julia hljs">newick_string = newick(tree)
open(&quot;flu_sim.tre&quot;,&quot;w&quot;) do io
   println(io,newick_string)
end</code></pre><p>Then we can set up a model. In this case, it&#39;ll be a combination of a nucleotide model of sequence evolution and Brownian motion over a continuous character.</p><pre><code class="language-julia hljs">nuc_freqs = [0.2,0.3,0.3,0.2]
nuc_rates = [1.0,2.0,1.0,1.0,1.6,0.5]
nuc_model = DiagonalizedCTMC(reversibleQ(nuc_rates,nuc_freqs))
bm_model = BrownianMotion(0.0,1.0)</code></pre><p>As usual, we set up the <code>Partition</code> structure, and load this onto our tree:</p><pre><code class="language-julia hljs">message_template = [NucleotidePartition(nuc_freqs,300),GaussianPartition()]
internal_message_init!(tree, message_template)</code></pre><p>Then we sample data under our model:</p><pre><code class="language-julia hljs">sample_down!(tree, [nuc_model,bm_model])</code></pre><p>We&#39;ll can visualize the Brownian component of the simulation by loading it into the <code>node_dict</code>, and converting to a <code>Phylo.jl</code> tree.</p><pre><code class="language-julia hljs">for n in getnodelist(tree)
    n.node_data = Dict([&quot;mu&quot;=&gt;n.message[2].mean])
end
phylo_tree = get_phylo_tree(tree)
plot(phylo_tree, showtips = false, line_z = &quot;mu&quot;, colorbar = :none,
    linecolor = :darkrainbow, linewidth = 1.0, size = (600, 600))</code></pre><p><img src="../figures/flu_tree_bm.svg" alt/></p><p>We can write the simulated data, including sequences and continuous characters, to a CSV:</p><pre><code class="language-julia hljs">df = DataFrame()
df.names = [n.name for n in getleaflist(tree)]
df.seqs = [partition2obs(n.message[1]) for n in getleaflist(tree)]
df.mu = [partition2obs(n.message[2]) for n in getleaflist(tree)]
CSV.write(&quot;flu_sim_seq_and_bm.csv&quot;,df)</code></pre><p>Or we could export just the sequences as .fasta</p><pre><code class="language-julia hljs">write_fasta(&quot;flu_sim_seq_and_bm.fasta&quot;,df.seqs,seq_names = df.names)</code></pre><p>Which will look something like this, when opened in <a href="https://ormbunkar.se/aliview/">AliView</a></p><p><img src="../figures/flu_sim_alignment.png" alt/></p><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.sim_tree" href="#MolecularEvolution.sim_tree"><code>MolecularEvolution.sim_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sim_tree(add_limit::Int,Ne_func,sample_rate_func; nstart = 1, time = 0.0, mutation_rate = 1.0, T = Float64)</code></pre><p>Simulates a tree of type FelNode{T}. Allows an effective population size function (Ne<em>func), as well as a sample rate function (sample</em>rate_func), which can also just be constants.</p><p>Ne<em>func(t) = (sin(t/10)+1)*100.0 + 10.0 root = sim</em>tree(600,Ne<em>func,1.0) simple</em>tree_draw(ladderize(root))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/f0daf7814c395824db27b7b52ef655df1e5ab1ce/src/core/sim_tree.jl#L94-L103">source</a></section><section><div><pre><code class="language-julia hljs">sim_tree(;n = 10)</code></pre><p>Simulates tree with constant population size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/f0daf7814c395824db27b7b52ef655df1e5ab1ce/src/core/sim_tree.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.sample_down!" href="#MolecularEvolution.sample_down!"><code>MolecularEvolution.sample_down!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>sample<em>down!(root::FelNode,models,partition</em>list)</p><p>Generates samples under the model. The root.parent<em>message is taken as the starting distribution, and node.message contains the sampled messages. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have &gt;1 Partition, or  a function that takes a node, and returns a Vector{&lt;:BranchModel} if you need the models to vary from one branch to another. partition</em>list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/f0daf7814c395824db27b7b52ef655df1e5ab1ce/src/core/algorithms/generative.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.partition2obs" href="#MolecularEvolution.partition2obs"><code>MolecularEvolution.partition2obs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">partition2obs(part::Partition)</code></pre><p>Extracts the most likely state from a Partition, transforming it into a convenient type. For example, a NucleotidePartition will be transformed into a nucleotide sequence of type String. Note: You should overload this for your own Partititon types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/MolecularEvolution.jl/blob/f0daf7814c395824db27b7b52ef655df1e5ab1ce/src/models/discrete_models/utils/seq_to_vec.jl#L70-L76">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/">« Models</a><a class="docs-footer-nextpage" href="../optimization/">Optimization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 11 September 2022 00:36">Sunday 11 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
