var documenterSearchIndex = {"docs":
[{"location":"optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"simulation/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The two key steps in phylogenetic simulation are 1) simulating the phylogeny itself, and 2) simulating data that evolves over the phylogeny.","category":"page"},{"location":"simulation/#Simulating-phylogenies","page":"Simulation","title":"Simulating phylogenies","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":":warning: WARNING\nWhile our sim_tree function seems to produce trees with the right shape, and is good enough for eg. generating varied tree shapes to evaluate different phylogeny inference schemes under, it is not yet sufficiently checked and tested for use where the details of the coalescent need to be absolutely accurate. It could, for example, be off by a constant factor somewhere. So if you plan on using this in a such a manner for a publication, please check the sim_tree code (and let us know).","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"If you just need a simple tree for testing things, then you can just use:","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"tree = sim_tree(n=100)\ntree_draw(tree, draw_labels = false, canvas_height = 5cm)","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"(Image: )","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"This has the characteristic \"coalescent under constant population size\" look.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"However, sim_tree is a bit more powerful than this: it aims to simulate branching under a coalescent process with flexible options for how the effective population size, as well as the sampling rate, might change over time. This is important, because the \"constant population size\" model is quite extreme, and most of the divergence happens in the early internal branches.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"A coalescent process runs backwards in time, starting from the most recent tip, and sampling backwards toward the root, coalescing nodes as it goes, and sometimes adding additional sampled tips. With simtree, if nstart = `addlimit`, then all the tips will be sampled at the same time, and the tree will be ultrametric.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"simtree has two arguments driving its flexibility. We'll start with \"samplingrate\", which controls the rate at which samples are added to the tree. Even under constant effective population size, this can produce interesting behavior.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"for sampling_rate in [5.0, 0.5, 0.05, 0.005]\n    tree = sim_tree(100,1000.0,sampling_rate)\n    display(tree_draw(tree, draw_labels = false, canvas_height = 5cm))\nend","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Above, this rate was just a fixed constant value, but we can also let this be a function. In this example, we'll plot the tree alongside the sampling rate function, as well as the cumulative number of samples through time.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"s(t) = ifelse(0<mod(t/10,10)<1,10.0,0.0)\ntree = sim_tree(500,500.0,s)\ndisplay(tree_draw(tree, draw_labels = false, canvas_height = 5cm, canvas_width = 23cm))\n\n#Figure out how tall the tree is\nroot_dists,_ = MolecularEvolution.root2tip_distances(tree)\nmrd = maximum(root_dists)\nsample_times = mrd .- root_dists\nxvals = 0.0:0.1:mrd\ndisplay(plot(xvals,s, xflip = true, size = (500,250), xlabel = \"time\",ylabel = \"sampling rate\", legend = :none))\ndisplay(plot(xvals,x -> sum(x .> sample_times), xflip = true, size = (500,250), xlabel = \"time\",ylabel = \"cumulative samples\", legend = :none))","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Note how the x axis of these plots is flipped, since the leaf furtherest from the root begins at time=0, and the coalescent runs backwards, from tip to root.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"We can also vary the effective population size over time, which adds a different dimension of control. Here is an example showing the shape of a tree under exponential growth:","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"n(t) = 100000*exp(-t/10)\ntree = sim_tree(100,n,100.0, nstart = 100)\ndisplay(tree_draw(tree, draw_labels = false, canvas_height = 7cm, canvas_width = 23cm))\n\nroot_dists,_ = MolecularEvolution.root2tip_distances(tree)\nplot(0.0:0.1:maximum(root_dists),n, xflip = true, size = (500,250), xlabel = \"time\",ylabel = \"effective population size\", legend = :none)","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"(Image: ) (Image: )","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Logistic growth, with a relatively low sampling rate, provides a reasonable model of an emerging virus that was only sampled later in its growth trajectory, such as HIV.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"n(t) = 10000/(1+exp(t-10))\ntree = sim_tree(100,n,20.0)\ndisplay(tree_draw(tree, draw_labels = false, canvas_height = 7cm, canvas_width = 23cm))\n\nroot_dists,_ = MolecularEvolution.root2tip_distances(tree)\ndisplay(plot(0.0:0.1:maximum(root_dists),n, xflip = true, size = (500,250), xlabel = \"time\",ylabel = \"effective population size\", legend = :none))\n\nmrd = maximum(root_dists)\nsample_times = mrd .- root_dists\nplot(0.0:0.1:mrd,x -> sum(x .> sample_times), xflip = true, size = (500,250), xlabel = \"time\",ylabel = \"cumulative samples\", legend = :none)","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"How about a virus with a seasonally varying effective population size, where sampling is proportional to case counts? Between seasons, the effective population size gets so low that the next seasons clade arises from a one or two lineages in the previous season.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"n(t) = exp(sin(t/10) * 2.0 + 4)\ns(t) = n(t)/100\ntree = sim_tree(500,n,s)\ndisplay(tree_draw(tree, draw_labels = false))\n\n\nroot_dists,_ = MolecularEvolution.root2tip_distances(tree)\ndisplay(plot(0.0:0.1:maximum(root_dists),n, xflip = true, size = (500,250), xlabel = \"time\",ylabel = \"effective population size\", legend = :none))\n\nmrd = maximum(root_dists)\nsample_times = mrd .- root_dists\nplot(0.0:0.1:mrd,x -> sum(x .> sample_times), xflip = true, size = (500,250), xlabel = \"time\",ylabel = \"cumulative samples\", legend = :none)","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Finally, the mutation_rate argument multiplicatively scales the branch lengths.","category":"page"},{"location":"simulation/#Simulating-evolution-over-phylogenies","page":"Simulation","title":"Simulating evolution over phylogenies","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Coming soon.","category":"page"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/#Example-1:-Amino-acid-ancestral-reconstruction-and-visualization","page":"Quick Start","title":"Example 1: Amino acid ancestral reconstruction and visualization","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"This example reads amino acid sequences from this FASTA file, and a phylogeny from this Newick tree file. A WAG amino acid model, augmented to explicitly model gap (ie. '-') characters, and a global substitution rate is estimated by maximum likelihood. Under this optimized model, the distribution over ancestral amino acids is constructed for each node, and visualized in multiple ways.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using MolecularEvolution, FASTX, Phylo, Plots\n\n#Read in seqs and tree\nseqnames, seqs = read_fasta(\"Data/MusAA_IGHV.fasta\")\ntree = read_newick_tree(\"Data/MusAA_IGHV.tre\")\n\n#Compute AA freqs, which become the equilibrium freqs of the model, and the initial root freqs\nAA_freqs = char_proportions(seqs,MolecularEvolution.gappyAAstring)\n#Build the Q matrix\nQ = gappy_Q_from_symmetric_rate_matrix(WAGmatrix,1.0,AA_freqs)\n#Build the model\nm = DiagonalizedCTMC(Q)\n#Set up the memory on the tree\ninitial_partition = GappyAminoAcidPartition(AA_freqs,length(seqs[1]))\npopulate_tree!(tree,initial_partition,seqnames,seqs)\n\n#Set up a likelihood function to find the scaling constant that best fits the branch lengths of the imported tree\n#Note, calling LL will change the rate, so make sure you set it to what you want after this has been called\nll = function(rate; m = m)\n    m.r = rate\n    return log_likelihood!(tree,m)\nend\nopt_rate = golden_section_maximize(ll, 0.0, 10.0, identity, 1e-11);\nplot(opt_rate*0.87:0.001:opt_rate*1.15,ll,size = (500,250),\n    xlabel = \"rate\",ylabel = \"log likelihood\", legend = :none)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Then set the model parameters to the maximum likelihood estimate, and reconstruct the ancestral states.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"m.r = opt_rate\n#Reconstructing the marginal distributions of amino acids at internal nodes\nd = marginal_state_dict(tree,m)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"That's it! Everything else is for visualizing these ancestral states. We'll select a set of amino acid positions to visualize, corresponding to these two (red arrows) alignment columns:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"#The alignment indices we want to pay attention to in our reconstructions\nmotif_inds = [52,53]\n\n#We'll compute a confidence score for the inferred marginal state\nconfidence(state,inds) = minimum([maximum(state[:,i]) for i in inds])\n\n#Map motifs to numbers, so we can work with more convenient continuous color scales\nall_motifs = sort(union([partition2obs(d[n][1])[motif_inds] for n in getnodelist(tree)]))\nmotif2num = Dict(zip(all_motifs,1:length(all_motifs)))\n\n#Populating the node_data dictionary to help with plotting\nfor n in getnodelist(tree)\n    moti = partition2obs(d[n][1])[motif_inds]\n    n.node_data = Dict([\n            \"motif\"=>moti,\n            \"motif_color\"=>motif2num[moti],\n            \"uncertainty\"=>1-confidence(d[n][1].state,motif_inds)\n            ])\nend\n\n#Transducing the MolecularEvolution FelNode tree to a Phylo.jl tree, which migrates node_data as well\nphylo_tree = get_phylo_tree(tree)\nnode_unc = values_from_phylo_tree(phylo_tree,\"uncertainty\")\n\nprintln(\"Greatest motif uncertainty: \",maximum([n.node_data[\"uncertainty\"] for n in getnodelist(tree)]))","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Greatest motif uncertainty: 0.6104376723068156","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"#Plotting, using discrete marker colors\npl = plot(phylo_tree,\n    showtips = true, tipfont = 6, marker_group = \"motif\", palette = :seaborn_bright,\n    markeralpha = 0.75, markerstrokewidth = 0, margins = 2Plots.cm, legend = :topleft,\n    linewidth = 1.5, size = (400, 800))\n\nsavefig_tweakSVG(\"anc_tree_with_legend.svg\", plot = pl)\npl","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"#Plotting, using discrete marker colors\npl = plot(phylo_tree, treetype = :fan,\n    showtips = true, tipfont = 6, marker_group = \"motif\", palette = :seaborn_bright,\n    markeralpha = 0.75, markerstrokewidth = 0, margins = 2Plots.cm, legend = :topleft,\n    linewidth = 1.5, size = (800, 800))\n\nsavefig_tweakSVG(\"anc_circ_tree_with_legend.svg\", plot = pl)\npl","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"#Plotting using continuous color scales, and using marker size to show uncertainty in reconstructions\ncolor_scale = :rainbow\npl = plot(phylo_tree, showtips = true, tipfont = 6, marker_z = \"motif_color\", line_z = \"motif_color\",\n    markersize = 10 .* sqrt.(node_unc), linecolor = color_scale, markercolor = color_scale, markeralpha = 0.75,\n    markerstrokewidth = 0,margins = 2Plots.cm, colorbar = :none, linewidth = 2.5,  size = (400, 800))\n\n#Feeble attempt at a manual legend\nmotif_ys = collect(1:length(all_motifs)) .+ (length(seqs) - length(all_motifs))\nscatter!(zeros(length(all_motifs)) , motif_ys , marker = 8, markeralpha = 0.75,\n        marker_z = 1:length(all_motifs), markercolor = color_scale, markerstrokewidth = 0.0)\nfor i in 1:length(all_motifs)\n    annotate!(0.1, motif_ys[i], all_motifs[i],7)\nend\n\nsavefig_tweakSVG(\"anc_tree_continuous.svg\", plot = pl)\npl","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"ancestors/#Ancestral-Reconstruction","page":"Ancestral Reconstruction","title":"Ancestral Reconstruction","text":"","category":"section"},{"location":"ancestors/","page":"Ancestral Reconstruction","title":"Ancestral Reconstruction","text":"Given a phylogeny, and observations on some set of leaf nodes, \"ancestral reconstruction\" describes a family of approaches for inferring the state of the ancestors, or the distribution over possible states of ancestors.","category":"page"},{"location":"ancestors/#Examples","page":"Ancestral Reconstruction","title":"Examples","text":"","category":"section"},{"location":"ancestors/","page":"Ancestral Reconstruction","title":"Ancestral Reconstruction","text":"using MolecularEvolution\n\n#Simulate a small tree, with Brownian motion over it\ntree = sim_tree(n=10)\ninternal_message_init!(tree, GaussianPartition())\nbm_model = BrownianMotion(0.0,0.1)\nsample_down!(tree, bm_model)\n\nr(x) = round(x,sigdigits = 3)\nprintln(\"Leaf values:\")\nfor n in getleaflist(tree)\n    println(n.name,\" : \",r(n.message[1].mean))\nend\n\nd = marginal_state_dict(tree,bm_model)\nprintln(\"Inferred internal means (±95% intervals):\")\nfor n in getnonleaflist(tree)\n    m,s = d[n][1].mean,sqrt(d[n][1].var)\n    println(r(m), \"±\", r(1.96*s), \" - true value: \",r(n.message[1].mean))\nend","category":"page"},{"location":"ancestors/","page":"Ancestral Reconstruction","title":"Ancestral Reconstruction","text":"Leaf values:\ntax8 : -1.03\ntax1 : -1.15\ntax9 : -1.67\ntax10 : -0.112\ntax6 : -0.0183\ntax2 : -0.0574\ntax3 : 0.207\ntax5 : 0.0021\ntax4 : 0.634\ntax7 : 0.544\nInferred internal means (±95% intervals):\n-0.485±0.815 - true value: -0.587\n-1.17±0.556 - true value: -1.37\n-1.1±0.256 - true value: -1.09\n0.116±0.45 - true value: 0.21\n0.0275±0.35 - true value: -0.035\n0.0216±0.283 - true value: 0.0177\n0.0459±0.13 - true value: 0.0485\n0.0532±0.122 - true value: 0.075\n0.571±0.147 - true value: 0.589","category":"page"},{"location":"ancestors/","page":"Ancestral Reconstruction","title":"Ancestral Reconstruction","text":"We can also find the values of the state for each node that are jointly most likely (in the case of Brownian motion, these just happen to be the same as the marginal means, but that isn't the case for other models):","category":"page"},{"location":"ancestors/","page":"Ancestral Reconstruction","title":"Ancestral Reconstruction","text":"d = max_joint_state_dict(tree,bm_model)\nprintln(\"Inferred most likely (jointly) internal values:\")\nfor n in getnonleaflist(tree)\n    m = d[n][1].mean\n    println(r(m), \" - true value: \",r(n.message[1].mean))\nend","category":"page"},{"location":"ancestors/","page":"Ancestral Reconstruction","title":"Ancestral Reconstruction","text":"Inferred most likely (jointly) internal values:\n-0.485 - true value: -0.587\n-1.17 - true value: -1.37\n-1.1 - true value: -1.09\n0.116 - true value: 0.21\n0.0275 - true value: -0.035\n0.0216 - true value: 0.0177\n0.0459 - true value: 0.0485\n0.0532 - true value: 0.075\n0.571 - true value: 0.589","category":"page"},{"location":"ancestors/","page":"Ancestral Reconstruction","title":"Ancestral Reconstruction","text":"And we can sample internal states under our model, but conditioned on the leaf observations:","category":"page"},{"location":"ancestors/","page":"Ancestral Reconstruction","title":"Ancestral Reconstruction","text":"d = endpoint_conditioned_sample_state_dict(tree,bm_model)\nprintln(\"Sampled states, conditioned on observed leaves:\")\nfor n in getnonleaflist(tree)\n    m = d[n][1].mean\n    println(r(m), \" - true value: \",r(n.message[1].mean))\nend","category":"page"},{"location":"ancestors/","page":"Ancestral Reconstruction","title":"Ancestral Reconstruction","text":"Sampled states, conditioned on observed leaves:\n-0.784 - true value: -0.587\n-1.3 - true value: -1.37\n-1.13 - true value: -1.09\n-0.155 - true value: 0.21\n0.0118 - true value: -0.035\n0.0305 - true value: 0.0177\n0.0913 - true value: 0.0485\n0.0542 - true value: 0.075\n0.498 - true value: 0.589","category":"page"},{"location":"ancestors/#Functions","page":"Ancestral Reconstruction","title":"Functions","text":"","category":"section"},{"location":"ancestors/","page":"Ancestral Reconstruction","title":"Ancestral Reconstruction","text":"marginal_state_dict\nmax_joint_state_dict\nendpoint_conditioned_sample_state_dict","category":"page"},{"location":"ancestors/#MolecularEvolution.marginal_state_dict","page":"Ancestral Reconstruction","title":"MolecularEvolution.marginal_state_dict","text":"marginal_state_dict(tree::FelNode, model; partition_list = 1:length(tree.message), node_message_dict = Dict{FelNode,Vector{Partition}}())\n\nTakes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode->Array{<:BranchModel}), and returns a dictionary mapping nodes to their marginal reconstructions (ie. P(state|all observations,model)). A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you're running this over and over.\n\n\n\n\n\n","category":"function"},{"location":"ancestors/#MolecularEvolution.max_joint_state_dict","page":"Ancestral Reconstruction","title":"MolecularEvolution.max_joint_state_dict","text":"max_joint_state_dict(tree::FelNode, model; partition_list = 1:length(tree.message), node_message_dict = Dict{FelNode,Vector{Partition}}())\n\nTakes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode->Array{<:BranchModel}), and returns a dictionary mapping nodes to their joint maximum likelihood reconstructions (ie. state, such that P(state|all observations,model) is maximized). A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you're running this over and over.\n\n\n\n\n\n","category":"function"},{"location":"ancestors/#MolecularEvolution.endpoint_conditioned_sample_state_dict","page":"Ancestral Reconstruction","title":"MolecularEvolution.endpoint_conditioned_sample_state_dict","text":"endpoint_conditioned_sample_state_dict(tree::FelNode, model; partition_list = 1:length(tree.message), node_message_dict = Dict{FelNode,Vector{Partition}}())\n\nTakes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode->Array{<:BranchModel}), and draws samples under the model conditions on the leaf observations. These samples are stored in the nodemessagedict, which is returned. A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you're running this over and over.\n\n\n\n\n\n","category":"function"},{"location":"viz/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"We offer two routes to visualization. The first is using our own plotting routines, built atop Compose.jl. The second converts our trees to Phylo.jl trees, and plots with their Plots.jl recipes. The Compose, Plots, and Phylo dependencies are optional.","category":"page"},{"location":"viz/#Example-1","page":"Visualization","title":"Example 1","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"using MolecularEvolution, Plots, Phylo\n\n#First simulate a tree, and then Brownian motion:\ntree = sim_tree(n=20)\ninternal_message_init!(tree, GaussianPartition())\nbm_model = BrownianMotion(0.0,0.1)\nsample_down!(tree, bm_model)\n\n#We'll add the Gaussian means to the node_data dictionaries\nfor n in getnodelist(tree)\n    n.node_data = Dict([\"mu\"=>n.message[1].mean])\nend\n\n#Transducing the mol ev tree to a Phylo.jl tree\nphylo_tree = get_phylo_tree(tree)\n\npl = plot(phylo_tree,\n    showtips = true, tipfont = 6, marker_z = \"mu\", markeralpha = 0.5, line_z = \"mu\", linecolor = :darkrainbow, \n    markersize = 4.0, markerstrokewidth = 0,margins = 1Plots.cm,\n    linewidth = 1.5, markercolor = :darkrainbow, size = (500, 500))","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"We also offer savefig_tweakSVG(\"simple_plot_example.svg\", plot = pl) for some post-processing tricks that improve the exported trees, like rounding line caps, and values_from_phylo_tree(phylo_tree,\"mu\") which can extract stored quantities in the right order for passing into eg. markersize options when plotting.","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"For a more comprehensive list of things you can do with Phylo.jl plots, please see their documentation.","category":"page"},{"location":"viz/#Coming-soon.","page":"Visualization","title":"Coming soon.","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"Examples using Compose dependent plots.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MolecularEvolution","category":"page"},{"location":"#MolecularEvolution","page":"Home","title":"MolecularEvolution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MolecularEvolution.","category":"page"},{"location":"#A-Julia-package-for-the-flexible-development-of-phylogenetic-models.","page":"Home","title":"A Julia package for the flexible development of phylogenetic models.","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MolecularEvolution.jl exploits Julia's multiple dispatch, implementing a fully generic suite of likelihood calculations, branchlength optimization, topology optimization, and ancestral inference. Users can construct trees using already-defined data types and models. But users can define probability distributions over their own data types, and specify the behavior of these under their own model types, and can mix and match different models on the same phylogeny.","category":"page"},{"location":"#Authors:","page":"Home","title":"Authors:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Venkatesh Kumar and Ben Murrell, with additional contributions by Sanjay Mohan, Alec Pankow, and Kenta Sato.","category":"page"},{"location":"#Quick-example:-Likelihood-calculations-under-phylogenetic-Brownian-motion:","page":"Home","title":"Quick example: Likelihood calculations under phylogenetic Brownian motion:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using MolecularEvolution, Plots\n\n#First simulate a tree, using a coalescent process\ntree = sim_tree(n=200)\ninternal_message_init!(tree, GaussianPartition())\n#Simulate brownian motion over the tree\nbm_model = BrownianMotion(0.0,1.0)\nsample_down!(tree, bm_model)\n#And plot the log likelihood as a function of the parameter value\nll(x) = log_likelihood!(tree,BrownianMotion(0.0,x))\nplot(0.7:0.001:1.6,ll, xlabel = \"variance per unit time\", ylabel = \"log likelihood\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MolecularEvolution]","category":"page"},{"location":"#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractTreeNode","page":"Home","title":"Base.:==","text":"==(t1, t2)\nDefaults to pointer equality\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution._mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any, Any}} where T<:Function","page":"Home","title":"MolecularEvolution._mapreduce","text":"Internal function. Helper for bfsmapreduce and dfsmapreduce\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.bfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T<:Function","page":"Home","title":"MolecularEvolution.bfs_mapreduce","text":"Performs a BFS map-reduce over the tree, starting at a given node For each node, mapreduce is called as:    mapreduce(currnode::FelNode, prevnode::FelNode, aggregator) where prev_node is the previous node visited on the path from the start node to the current node It is expected to update the aggregator, and not return anything.\n\nNot exactly conventional map-reduce, as map-reduce calls may rely on state in the aggregator added by map-reduce calls on other nodes visited earlier.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.branchlength_optim!-Tuple{FelNode, Any}","page":"Home","title":"MolecularEvolution.branchlength_optim!","text":"branchlength_optim!(tree::FelNode, models; partition_list = nothing, tol = 1e-5)\n\nUses golden section search to optimize all branches recursively, maintaining the integrity of the messages. Requires felsenstein!() to have been run first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have >1 Partition, or  a function that takes a node, and returns a Vector{<:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over (but you probably want to optimize branch lengths with all models). tol is the tolerance for the golden section search.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.deepequals-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractTreeNode","page":"Home","title":"MolecularEvolution.deepequals","text":"deepequals(t1, t2)\n\nChecks whether two trees are equal by recursively calling this on all fields, except :parent, in order to prevent cycles. In order to ensure that the :parent field is not hiding something different on both trees, ensure that each is consistent first (see: istreeconsistent).\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.dfs_mapreduce-Union{Tuple{T}, Tuple{AbstractTreeNode, T, Any}} where T<:Function","page":"Home","title":"MolecularEvolution.dfs_mapreduce","text":"Performs a DFS map-reduce over the tree, starting at a given node See bfs_mapreduce for more details.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.endpoint_conditioned_sample_state_dict-Tuple{FelNode, Any}","page":"Home","title":"MolecularEvolution.endpoint_conditioned_sample_state_dict","text":"endpoint_conditioned_sample_state_dict(tree::FelNode, model; partition_list = 1:length(tree.message), node_message_dict = Dict{FelNode,Vector{Partition}}())\n\nTakes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode->Array{<:BranchModel}), and draws samples under the model conditions on the leaf observations. These samples are stored in the nodemessagedict, which is returned. A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you're running this over and over.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.expected_subs_per_site-Tuple{Any, Any}","page":"Home","title":"MolecularEvolution.expected_subs_per_site","text":"expected_subs_per_site(Q,mu)\n\nTakes a rate matrix Q and an equilibrium frequency vector, and calculates the expected number of substitutions per site.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.felsenstein!-Tuple{FelNode, Any}","page":"Home","title":"MolecularEvolution.felsenstein!","text":"felsenstein!(node::FelNode, models; partition_list = nothing)\n\nShould usually be called on the root of the tree. Propagates Felsenstein pass up from the tips to the root. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have >1 Partition, or  a function that takes a node, and returns a Vector{<:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.felsenstein_down!-Tuple{FelNode, Any}","page":"Home","title":"MolecularEvolution.felsenstein_down!","text":"felsenstein_down!(node::FelNode, models; partition_list = 1:length(tree.message), temp_message = deepcopy(tree.message))\n\nShould usually be called on the root of the tree. Propagates Felsenstein pass down from the root to the tips. felsenstein!() should usually be called first. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have >1 Partition, or  a function that takes a node, and returns a Vector{<:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.golden_section_maximize-Tuple{Any, Real, Real, Any, Real}","page":"Home","title":"MolecularEvolution.golden_section_maximize","text":"Golden section search.\n\nGiven a function f with a single local minimum in the interval [a,b], gss returns a subset interval [c,d] that contains the minimum with d-c <= tol.\n\nExamples\n\njulia> f(x) = -(x-2)^2\nf (generic function with 1 method)\n\njulia> m = golden_section_maximize(f, 1, 5, identity, 1e-10)\n2.0000000000051843\n\nFrom: https://en.wikipedia.org/wiki/Golden-section_search\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.internal_message_init!-Tuple{FelNode, Partition}","page":"Home","title":"MolecularEvolution.internal_message_init!","text":"internal_message_init!(tree::FelNode, partition::Partition)\n\nInitializes the message template for each node in the tree, as an array of the partition.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.internal_message_init!-Tuple{FelNode, Vector{<:Partition}}","page":"Home","title":"MolecularEvolution.internal_message_init!","text":"internal_message_init!(tree::FelNode, empty_message::Vector{<:Partition})\n\nInitializes the message template for each node in the tree, allocating space for each partition.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.istreeconsistent-Tuple{T} where T<:AbstractTreeNode","page":"Home","title":"MolecularEvolution.istreeconsistent","text":"istreeconsistent(root)\n\nChecks whether the :parent field is set to be consistent with the :child field for all nodes in the subtree. \n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.linear_scale-NTuple{5, Any}","page":"Home","title":"MolecularEvolution.linear_scale","text":"linear_scale(val,in_min,in_max,out_min,out_max)\n\nLinearly maps val which lives in [inmin,inmax] to a value in [outmin,outmax]\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.log_likelihood!-Tuple{FelNode, Any}","page":"Home","title":"MolecularEvolution.log_likelihood!","text":"log_likelihood!(tree::FelNode, models; partition_list = nothing)\n\nFirst re-computes the upward felsenstein pass, and then computes the log likelihood of this tree. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have >1 Partition, or  a function that takes a node, and returns a Vector{<:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.log_likelihood-Tuple{FelNode, BranchModel}","page":"Home","title":"MolecularEvolution.log_likelihood","text":"log_likelihood(tree::FelNode, models; partition_list = nothing)\n\nComputed the log likelihood of this tree. Requires felsenstein!() to have been run. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have >1 Partition, or  a function that takes a node, and returns a Vector{<:BranchModel} if you need the models to vary from one branch to another. partition_list (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.longest_path-Tuple{FelNode}","page":"Home","title":"MolecularEvolution.longest_path","text":"Returns the longest path in a tree For convenience, this is returned as two lists of form:     [leafnode, parentnode, .... root] Where the leaf_node nodes are selected to be the furthest away\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.marginal_state_dict-Tuple{FelNode, Any}","page":"Home","title":"MolecularEvolution.marginal_state_dict","text":"marginal_state_dict(tree::FelNode, model; partition_list = 1:length(tree.message), node_message_dict = Dict{FelNode,Vector{Partition}}())\n\nTakes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode->Array{<:BranchModel}), and returns a dictionary mapping nodes to their marginal reconstructions (ie. P(state|all observations,model)). A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you're running this over and over.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.max_joint_state_dict-Tuple{FelNode, Any}","page":"Home","title":"MolecularEvolution.max_joint_state_dict","text":"max_joint_state_dict(tree::FelNode, model; partition_list = 1:length(tree.message), node_message_dict = Dict{FelNode,Vector{Partition}}())\n\nTakes in a tree and a model (which can be a single model, an array of models, or a function that maps FelNode->Array{<:BranchModel}), and returns a dictionary mapping nodes to their joint maximum likelihood reconstructions (ie. state, such that P(state|all observations,model) is maximized). A subset of partitions can be specified by partition_list, and a dictionary can be passed in to avoid re-allocating memory, in case you're running this over and over.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.midpoint-Tuple{FelNode}","page":"Home","title":"MolecularEvolution.midpoint","text":"Returns a midpoint as a node and a distance above it where the midpoint is\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.name2node_dict-Tuple{AbstractTreeNode}","page":"Home","title":"MolecularEvolution.name2node_dict","text":"name2node_dict(root)\n\nReturns a dictionary of leaf nodes, indexed by node.name. Can be used to associate sequences with leaf nodes.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.node_distances-Tuple{AbstractTreeNode}","page":"Home","title":"MolecularEvolution.node_distances","text":"Compute the distance to all other nodes from a given node\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.parent_list-Tuple{FelNode}","page":"Home","title":"MolecularEvolution.parent_list","text":"Provides a list of parent nodes nodes from this node up to the root node\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.quadratic_CI-Tuple{Function, Vector, Int64}","page":"Home","title":"MolecularEvolution.quadratic_CI","text":"quadratic_CI(f::Function,opt_params::Vector, param_ind::Int; rate_conf_level = 0.99, nudge_amount = 0.01)\n\nTakes a NEGATIVE log likelihood function (compatible with Optim.jl), a vector of maximizing parameters, an a parameter index. Returns the quadratic confidence interval.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.quadratic_CI-Tuple{Vector, Vector}","page":"Home","title":"MolecularEvolution.quadratic_CI","text":"quadratic_CI(xvec,yvec; rate_conf_level = 0.99)\n\nTakes xvec, a vector of parameter values, and yvec, a vector of log likelihood evaluations (note: NOT the negative LLs you) might use with Optim.jl. Returns the confidence intervals computed by a quadratic approximation to the LL.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.read_newick_tree-Tuple{String}","page":"Home","title":"MolecularEvolution.read_newick_tree","text":"readnewicktree(treefile)\n\nReads in a tree from a file, of type FelNode\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.root2tip_distances-Tuple{AbstractTreeNode}","page":"Home","title":"MolecularEvolution.root2tip_distances","text":"root2tips(root::AbstractTreeNode)\n\nReturns a vector of root-to-tip distances, and a node-to-index dictionary. Be aware that this dictionary will break when any of the node content (ie. anything on the tree) changes.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.sample_down!-Tuple{FelNode, Any, Any}","page":"Home","title":"MolecularEvolution.sample_down!","text":"sampledown!(root::FelNode,models,partitionlist)\n\nGenerates samples under the model. The root.parentmessage is taken as the starting distribution, and node.message contains the sampled messages. models can either be a single model (if the messages on the tree contain just one Partition) or an array of models, if the messages have >1 Partition, or  a function that takes a node, and returns a Vector{<:BranchModel} if you need the models to vary from one branch to another. partitionlist (eg. 1:3 or [1,3,5]) lets you choose which partitions to run over.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.sample_from_message!-Tuple{Vector{<:Partition}}","page":"Home","title":"MolecularEvolution.sample_from_message!","text":"sample_from_message!(message::Vector{<:Partition})\n\n#Replaces an uncertain message with a sample from the distribution represented by each partition.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.shortest_path_between_nodes-Tuple{FelNode, FelNode}","page":"Home","title":"MolecularEvolution.shortest_path_between_nodes","text":"Shortest path between nodes, returned as two lists, each starting with one of the two nodes,  and ending with the common ancestor\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.sibling_inds-Tuple{AbstractTreeNode}","page":"Home","title":"MolecularEvolution.sibling_inds","text":"sibling_inds(node)\n\nReturns logical indices of the siblings in the parent's child's vector.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.siblings-Tuple{AbstractTreeNode}","page":"Home","title":"MolecularEvolution.siblings","text":"siblings(node)\n\nReturns a vector of siblings of node.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.sim_tree-Tuple{Int64, Any, Any}","page":"Home","title":"MolecularEvolution.sim_tree","text":"sim_tree(add_limit::Int,Ne_func,sample_rate_func; nstart = 1, time = 0.0, mutation_rate = 1.0, T = Float64)\n\nSimulates a tree of type FelNode{T}. Allows an effective population size function (Nefunc), as well as a sample rate function (samplerate_func), which can also just be constants.\n\nNefunc(t) = (sin(t/10)+1)*100.0 + 10.0 root = simtree(600,Nefunc,1.0) simpletree_draw(ladderize(root))\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.sim_tree-Tuple{}","page":"Home","title":"MolecularEvolution.sim_tree","text":"sim_tree(;n = 10)\n\nSimulates tree with constant population size.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.simple_tree_opt!-Tuple{Any, Any}","page":"Home","title":"MolecularEvolution.simple_tree_opt!","text":"simple_tree_opt!(newt,models; tol = 10^-4, verbose = 0, topology = true)\n\nTakes a tree and a model function, and optimizes branch lengths and, optionally, topology.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.total_LL-Tuple{Partition}","page":"Home","title":"MolecularEvolution.total_LL","text":"total_LL(p::Partition)\n\nIf called on the root, it returns the log likelihood associated with that partition. Can be overloaded for complex partitions without straightforward site log likelihoods.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.tree2distances-Tuple{AbstractTreeNode}","page":"Home","title":"MolecularEvolution.tree2distances","text":"tree2distances(root::AbstractTreeNode)\n\nReturns a distance matrix for all pairs of leaf nodes, and a node-to-index dictionary. Be aware that this dictionary will break when any of the node content (ie. anything on the tree) changes.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.tree2shared_branch_lengths-Tuple{AbstractTreeNode}","page":"Home","title":"MolecularEvolution.tree2shared_branch_lengths","text":"tree2distances(root::AbstractTreeNode)\n\nReturns a distance matrix for all pairs of leaf nodes, and a node-to-index dictionary. Be aware that this dictionary will break when any of the node content (ie. anything on the tree) changes.\n\n\n\n\n\n","category":"method"},{"location":"types/#The-MolecularEvolution.jl-Framework","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"","category":"section"},{"location":"types/","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"The organizing principle is that the core algorithms, including Felsenstein's algorithm, but also a related family of message passing algorithms and inference machinery, are implemented in a way that does not refer to any specific model or even to any particular data type.","category":"page"},{"location":"types/#Partitions-and-BranchModels","page":"The MolecularEvolution.jl Framework","title":"Partitions and BranchModels","text":"","category":"section"},{"location":"types/","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"A Partition is a probabilistic representation of some kind of state. Specifically, it needs to be able to represent P(obs|state) and P(obs,state) when considered as functions of state. So it will typically be able to assign a probability to any possible value of state, and is unnormalized - not required to sum or integrate to 1 over all values of state. As an example, for a discrete state with 4 categories, this could just be a vector of 4 numbers.","category":"page"},{"location":"types/","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"For a Partition type to be usable by MolecularEvolution.jl, the combine! function needs to be implemented. If you have P(obsA|state) and P(obsB|state), then combine! calculates P(obsA,obsB|state) under the assumption that obsA and obsB are conditionally independent given state. MolecularEvolution.jl tries to avoid allocating memory, so combine!(dest,src) places in dest the combined Partition in dest. For a discrete state with 4 categories, this is simply element-wise multiplication of two state vectors.","category":"page"},{"location":"types/","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"A BranchModel defines how Partition distributions evolve along branches. Two functions need to be implemented: backward! and forward!. We imagine our trees with the root at the top, and forward! moves from root to tip, and backward! moves from tip to root. backward!(dest::P,src::P,m::BranchModel,n::FelNode) takes a src Partition, representing P(obs-below|state-at-bottom-of-branch), and modifies the dest Partition to be P(obs-below|state-at-top-of-branch), where the branch in question is the branch above the FelNode n. forward! goes in the opposite direction, from P(obs-above,state-at-top-of-branch) to P(obs-above,state-at-bottom-of-branch), with the Partitions now, confusingly, representing joint distributions.","category":"page"},{"location":"types/","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"(Image: )","category":"page"},{"location":"types/#Messages","page":"The MolecularEvolution.jl Framework","title":"Messages","text":"","category":"section"},{"location":"types/","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"Nodes on our trees work with messages, where a message is a vector of Partition structs. This is in case you wish to model multiple different data types on the same tree. Often, all the messages on the tree will just be arrays containing a single Partition, but if you're accessing them you need to remember that they're in an array!","category":"page"},{"location":"types/#Trees","page":"The MolecularEvolution.jl Framework","title":"Trees","text":"","category":"section"},{"location":"types/","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"Each node in our tree is a FelNode (\"Fel\" for \"Felsenstein\"). They point to their parent nodes, and an array of their children, and they store their main vector of Partitions, but also cached versions of those from their parents and children, to allow certain message passing schemes. They also have a branchlength field, which tells eg. forward! and backward! how much evolution occurs along the branch above (ie. closer to the root) that node. They also allow for an arbitrary dictionary of node_data, in case a model needs any other branch-specific parameters.","category":"page"},{"location":"types/","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"The set of algorithms needs to know which model to use for which partition, so the assumption made is that they'll see an array of models whose order will match the partition array. In general, we might want the models to vary from one branch to another, so the central algorithms take a function that associates a FelNode->Vector{:<BranchModel}. In the simpler cases where the model does not vary from branch to branch, or where there is only a single Partition, and thus a single model, the core algorithms have been overloaded to allow you to pass in a single model vector or a single model.","category":"page"},{"location":"types/#Algorithms","page":"The MolecularEvolution.jl Framework","title":"Algorithms","text":"","category":"section"},{"location":"types/","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"Felsenstein's algorithm recursively computes, for each node, the probability of all observations below that node, given the state at that node. Felsenstein's algorithm can be decomposed into the following combination of backward! and combine! operations:","category":"page"},{"location":"types/","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"(Image: )","category":"page"},{"location":"types/","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"At the root node, we wind up with P(all_observationsroot_state), and we can compute P(all_observations) = sum_state P(all_observationsroot_state) P(root_state).","category":"page"},{"location":"types/#Technical-Weeds","page":"The MolecularEvolution.jl Framework","title":"Technical Weeds","text":"","category":"section"},{"location":"types/","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"Scaling constants.","category":"page"},{"location":"types/","page":"The MolecularEvolution.jl Framework","title":"The MolecularEvolution.jl Framework","text":"Root state.","category":"page"}]
}
